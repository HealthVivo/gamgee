<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.8"/>
<title>Gamgee: gamgee::VariantBuilder Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Gamgee
   </div>
   <div id="projectbrief">You miserable little maggot. I&#39;ll stove your head in!</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.8 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(11)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacegamgee.html">gamgee</a></li><li class="navelem"><a class="el" href="classgamgee_1_1_variant_builder.html">VariantBuilder</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classgamgee_1_1_variant_builder-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">gamgee::VariantBuilder Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><a class="el" href="classgamgee_1_1_variant_builder.html" title="VariantBuilder: construct Variant records from scratch (and, coming soon, from existing Variant recor...">VariantBuilder</a>: construct <a class="el" href="classgamgee_1_1_variant.html" title="Utility class to manipulate a Variant record. ">Variant</a> records from scratch (and, coming soon, from existing <a class="el" href="classgamgee_1_1_variant.html" title="Utility class to manipulate a Variant record. ">Variant</a> records)  
 <a href="classgamgee_1_1_variant_builder.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="variant__builder_8h_source.html">variant_builder.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ace610039f04b4360626880dc9df306e1"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgamgee_1_1_variant_builder.html#ace610039f04b4360626880dc9df306e1">VariantBuilder</a> (const <a class="el" href="classgamgee_1_1_variant_header.html">VariantHeader</a> &amp;<a class="el" href="classgamgee_1_1_variant_builder.html#ad839d1da158385dc3fbd9a558d55b14b">header</a>)</td></tr>
<tr class="memdesc:ace610039f04b4360626880dc9df306e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a new <a class="el" href="classgamgee_1_1_variant_builder.html" title="VariantBuilder: construct Variant records from scratch (and, coming soon, from existing Variant recor...">VariantBuilder</a> given a <a class="el" href="classgamgee_1_1_variant_header.html" title="Utility class to hold a variant header. ">VariantHeader</a>.  <a href="#ace610039f04b4360626880dc9df306e1">More...</a><br /></td></tr>
<tr class="separator:ace610039f04b4360626880dc9df306e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ec544dd5021a2835cad4bf1fd7bab12"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgamgee_1_1_variant_builder.html#a7ec544dd5021a2835cad4bf1fd7bab12">VariantBuilder</a> (<a class="el" href="classgamgee_1_1_variant_builder.html">VariantBuilder</a> &amp;&amp;other)=default</td></tr>
<tr class="separator:a7ec544dd5021a2835cad4bf1fd7bab12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a224958078f9072126206c1e11c7d923b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classgamgee_1_1_variant_builder.html">VariantBuilder</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgamgee_1_1_variant_builder.html#a224958078f9072126206c1e11c7d923b">operator=</a> (<a class="el" href="classgamgee_1_1_variant_builder.html">VariantBuilder</a> &amp;&amp;other)=default</td></tr>
<tr class="separator:a224958078f9072126206c1e11c7d923b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25e8a88d0fe8330989aa2fc67866a09b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgamgee_1_1_variant_builder.html#a25e8a88d0fe8330989aa2fc67866a09b">VariantBuilder</a> (const <a class="el" href="classgamgee_1_1_variant_builder.html">VariantBuilder</a> &amp;other)=delete</td></tr>
<tr class="separator:a25e8a88d0fe8330989aa2fc67866a09b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc86504ec9138ed9505227f525245240"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classgamgee_1_1_variant_builder.html">VariantBuilder</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgamgee_1_1_variant_builder.html#afc86504ec9138ed9505227f525245240">operator=</a> (const <a class="el" href="classgamgee_1_1_variant_builder.html">VariantBuilder</a> &amp;other)=delete</td></tr>
<tr class="separator:afc86504ec9138ed9505227f525245240"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac288116a5f57f8d578435da482b3ca7b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgamgee_1_1_variant_builder.html#ac288116a5f57f8d578435da482b3ca7b">~VariantBuilder</a> ()=default</td></tr>
<tr class="separator:ac288116a5f57f8d578435da482b3ca7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad839d1da158385dc3fbd9a558d55b14b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classgamgee_1_1_variant_header.html">VariantHeader</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgamgee_1_1_variant_builder.html#ad839d1da158385dc3fbd9a558d55b14b">header</a> () const </td></tr>
<tr class="memdesc:ad839d1da158385dc3fbd9a558d55b14b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the <a class="el" href="classgamgee_1_1_variant.html" title="Utility class to manipulate a Variant record. ">Variant</a> header for this builder.  <a href="#ad839d1da158385dc3fbd9a558d55b14b">More...</a><br /></td></tr>
<tr class="separator:ad839d1da158385dc3fbd9a558d55b14b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cb2d600ba1e3249b1533fe7be9ae8f1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classgamgee_1_1_variant_builder.html">VariantBuilder</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgamgee_1_1_variant_builder.html#a7cb2d600ba1e3249b1533fe7be9ae8f1">set_enable_validation</a> (const bool enable_validation)</td></tr>
<tr class="memdesc:a7cb2d600ba1e3249b1533fe7be9ae8f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disable or enable all validation checks in this builder.  <a href="#a7cb2d600ba1e3249b1533fe7be9ae8f1">More...</a><br /></td></tr>
<tr class="separator:a7cb2d600ba1e3249b1533fe7be9ae8f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4494b555f8f0a09793c5d9da22ffc4a8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classgamgee_1_1_variant_builder.html">VariantBuilder</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgamgee_1_1_variant_builder.html#a4494b555f8f0a09793c5d9da22ffc4a8">set_chromosome</a> (const uint32_t chromosome)</td></tr>
<tr class="memdesc:a4494b555f8f0a09793c5d9da22ffc4a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the chromosome by index.  <a href="#a4494b555f8f0a09793c5d9da22ffc4a8">More...</a><br /></td></tr>
<tr class="separator:a4494b555f8f0a09793c5d9da22ffc4a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6062d271de74f46d6767b5847f6f359d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classgamgee_1_1_variant_builder.html">VariantBuilder</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgamgee_1_1_variant_builder.html#a6062d271de74f46d6767b5847f6f359d">set_chromosome</a> (const std::string &amp;chromosome)</td></tr>
<tr class="memdesc:a6062d271de74f46d6767b5847f6f359d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the chromosome by name.  <a href="#a6062d271de74f46d6767b5847f6f359d">More...</a><br /></td></tr>
<tr class="separator:a6062d271de74f46d6767b5847f6f359d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad76787fa7e4077b87d3c2ad414cd6371"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classgamgee_1_1_variant_builder.html">VariantBuilder</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgamgee_1_1_variant_builder.html#ad76787fa7e4077b87d3c2ad414cd6371">set_alignment_start</a> (const uint32_t alignment_start)</td></tr>
<tr class="memdesc:ad76787fa7e4077b87d3c2ad414cd6371"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the alignment start position.  <a href="#ad76787fa7e4077b87d3c2ad414cd6371">More...</a><br /></td></tr>
<tr class="separator:ad76787fa7e4077b87d3c2ad414cd6371"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af80e48e3d14ff5a9613660b54277bf4d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classgamgee_1_1_variant_builder.html">VariantBuilder</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgamgee_1_1_variant_builder.html#af80e48e3d14ff5a9613660b54277bf4d">set_alignment_stop</a> (const uint32_t alignment_stop)</td></tr>
<tr class="memdesc:af80e48e3d14ff5a9613660b54277bf4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the alignment stop position.  <a href="#af80e48e3d14ff5a9613660b54277bf4d">More...</a><br /></td></tr>
<tr class="separator:af80e48e3d14ff5a9613660b54277bf4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0a4a44483fe363a1e342f2c29681fae"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classgamgee_1_1_variant_builder.html">VariantBuilder</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgamgee_1_1_variant_builder.html#af0a4a44483fe363a1e342f2c29681fae">set_qual</a> (const float qual)</td></tr>
<tr class="memdesc:af0a4a44483fe363a1e342f2c29681fae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the Phred-scaled site quality (probability that the site is not reference)  <a href="#af0a4a44483fe363a1e342f2c29681fae">More...</a><br /></td></tr>
<tr class="separator:af0a4a44483fe363a1e342f2c29681fae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc79ab96a09514ea1a46dcbbceef3fef"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classgamgee_1_1_variant_builder.html">VariantBuilder</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgamgee_1_1_variant_builder.html#acc79ab96a09514ea1a46dcbbceef3fef">set_id</a> (const std::string &amp;id)</td></tr>
<tr class="memdesc:acc79ab96a09514ea1a46dcbbceef3fef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the variant ID field.  <a href="#acc79ab96a09514ea1a46dcbbceef3fef">More...</a><br /></td></tr>
<tr class="separator:acc79ab96a09514ea1a46dcbbceef3fef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab94db2cdc82ac4afc66b91ff1155fd49"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classgamgee_1_1_variant_builder.html">VariantBuilder</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgamgee_1_1_variant_builder.html#ab94db2cdc82ac4afc66b91ff1155fd49">set_ref_allele</a> (const std::string &amp;ref_allele)</td></tr>
<tr class="memdesc:ab94db2cdc82ac4afc66b91ff1155fd49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the reference allele.  <a href="#ab94db2cdc82ac4afc66b91ff1155fd49">More...</a><br /></td></tr>
<tr class="separator:ab94db2cdc82ac4afc66b91ff1155fd49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b1a027a239bfbdb9a3a8bec4203f28c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classgamgee_1_1_variant_builder.html">VariantBuilder</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgamgee_1_1_variant_builder.html#a8b1a027a239bfbdb9a3a8bec4203f28c">set_alt_allele</a> (const std::string &amp;alt_allele)</td></tr>
<tr class="memdesc:a8b1a027a239bfbdb9a3a8bec4203f28c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the alt allele.  <a href="#a8b1a027a239bfbdb9a3a8bec4203f28c">More...</a><br /></td></tr>
<tr class="separator:a8b1a027a239bfbdb9a3a8bec4203f28c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab90c4dd560168c88114280fc86543bbe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classgamgee_1_1_variant_builder.html">VariantBuilder</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgamgee_1_1_variant_builder.html#ab90c4dd560168c88114280fc86543bbe">set_alt_alleles</a> (const std::vector&lt; std::string &gt; &amp;alt_alleles)</td></tr>
<tr class="memdesc:ab90c4dd560168c88114280fc86543bbe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the alt alleles.  <a href="#ab90c4dd560168c88114280fc86543bbe">More...</a><br /></td></tr>
<tr class="separator:ab90c4dd560168c88114280fc86543bbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7d74effdfa3d0a05e5b430fb46b5339"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classgamgee_1_1_variant_builder.html">VariantBuilder</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgamgee_1_1_variant_builder.html#af7d74effdfa3d0a05e5b430fb46b5339">set_filters</a> (const std::vector&lt; std::string &gt; &amp;filters)</td></tr>
<tr class="memdesc:af7d74effdfa3d0a05e5b430fb46b5339"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the filters using filter names.  <a href="#af7d74effdfa3d0a05e5b430fb46b5339">More...</a><br /></td></tr>
<tr class="separator:af7d74effdfa3d0a05e5b430fb46b5339"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20952eb544025ff80c314c251962f3ee"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classgamgee_1_1_variant_builder.html">VariantBuilder</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgamgee_1_1_variant_builder.html#a20952eb544025ff80c314c251962f3ee">set_filters</a> (const std::vector&lt; int32_t &gt; &amp;filters)</td></tr>
<tr class="memdesc:a20952eb544025ff80c314c251962f3ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the filters using filter indices.  <a href="#a20952eb544025ff80c314c251962f3ee">More...</a><br /></td></tr>
<tr class="separator:a20952eb544025ff80c314c251962f3ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbfc654cff9b49d40c7b1b67df97cfad"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classgamgee_1_1_variant_builder.html">VariantBuilder</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgamgee_1_1_variant_builder.html#abbfc654cff9b49d40c7b1b67df97cfad">remove_alignment_stop</a> ()</td></tr>
<tr class="memdesc:abbfc654cff9b49d40c7b1b67df97cfad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear the alignment stop value (if set)  <a href="#abbfc654cff9b49d40c7b1b67df97cfad">More...</a><br /></td></tr>
<tr class="separator:abbfc654cff9b49d40c7b1b67df97cfad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a531375e15d4108ee508a4e2d6ff35fc4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classgamgee_1_1_variant_builder.html">VariantBuilder</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgamgee_1_1_variant_builder.html#a531375e15d4108ee508a4e2d6ff35fc4">remove_qual</a> ()</td></tr>
<tr class="memdesc:a531375e15d4108ee508a4e2d6ff35fc4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear the qual field (if set)  <a href="#a531375e15d4108ee508a4e2d6ff35fc4">More...</a><br /></td></tr>
<tr class="separator:a531375e15d4108ee508a4e2d6ff35fc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2bbb85da5628323df90e8822abbccf6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classgamgee_1_1_variant_builder.html">VariantBuilder</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgamgee_1_1_variant_builder.html#aa2bbb85da5628323df90e8822abbccf6">remove_id</a> ()</td></tr>
<tr class="memdesc:aa2bbb85da5628323df90e8822abbccf6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear the ID field (if set)  <a href="#aa2bbb85da5628323df90e8822abbccf6">More...</a><br /></td></tr>
<tr class="separator:aa2bbb85da5628323df90e8822abbccf6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e1adb976cb519752295ba81a4278d35"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classgamgee_1_1_variant_builder.html">VariantBuilder</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgamgee_1_1_variant_builder.html#a3e1adb976cb519752295ba81a4278d35">remove_alt_alleles</a> ()</td></tr>
<tr class="memdesc:a3e1adb976cb519752295ba81a4278d35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear alt alleles (if set)  <a href="#a3e1adb976cb519752295ba81a4278d35">More...</a><br /></td></tr>
<tr class="separator:a3e1adb976cb519752295ba81a4278d35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d4a69132f5d179dcf2def5ecc51f458"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classgamgee_1_1_variant_builder.html">VariantBuilder</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgamgee_1_1_variant_builder.html#a7d4a69132f5d179dcf2def5ecc51f458">remove_filters</a> ()</td></tr>
<tr class="memdesc:a7d4a69132f5d179dcf2def5ecc51f458"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear filters (if set)  <a href="#a7d4a69132f5d179dcf2def5ecc51f458">More...</a><br /></td></tr>
<tr class="separator:a7d4a69132f5d179dcf2def5ecc51f458"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fa488e941d9ec047f1fa5c02b85ea2e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classgamgee_1_1_variant_builder.html">VariantBuilder</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgamgee_1_1_variant_builder.html#a7fa488e941d9ec047f1fa5c02b85ea2e">set_integer_shared_field</a> (const std::string &amp;tag, const int32_t value)</td></tr>
<tr class="memdesc:a7fa488e941d9ec047f1fa5c02b85ea2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a single-valued integer shared field by field name.  <a href="#a7fa488e941d9ec047f1fa5c02b85ea2e">More...</a><br /></td></tr>
<tr class="separator:a7fa488e941d9ec047f1fa5c02b85ea2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65bdff18c82917e7a0bde43d64cae615"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classgamgee_1_1_variant_builder.html">VariantBuilder</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgamgee_1_1_variant_builder.html#a65bdff18c82917e7a0bde43d64cae615">set_integer_shared_field</a> (const std::string &amp;tag, const std::vector&lt; int32_t &gt; &amp;values)</td></tr>
<tr class="memdesc:a65bdff18c82917e7a0bde43d64cae615"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a multi-valued integer shared field by field name.  <a href="#a65bdff18c82917e7a0bde43d64cae615">More...</a><br /></td></tr>
<tr class="separator:a65bdff18c82917e7a0bde43d64cae615"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf2b2554997083141821365b163525c3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classgamgee_1_1_variant_builder.html">VariantBuilder</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgamgee_1_1_variant_builder.html#adf2b2554997083141821365b163525c3">set_integer_shared_field</a> (const uint32_t index, const int32_t value)</td></tr>
<tr class="memdesc:adf2b2554997083141821365b163525c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a single-valued integer shared field by field index.  <a href="#adf2b2554997083141821365b163525c3">More...</a><br /></td></tr>
<tr class="separator:adf2b2554997083141821365b163525c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71808bcd6e8512abe46832be92f9ccdb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classgamgee_1_1_variant_builder.html">VariantBuilder</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgamgee_1_1_variant_builder.html#a71808bcd6e8512abe46832be92f9ccdb">set_integer_shared_field</a> (const uint32_t index, const std::vector&lt; int32_t &gt; &amp;values)</td></tr>
<tr class="memdesc:a71808bcd6e8512abe46832be92f9ccdb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a multi-valued integer shared field by field index.  <a href="#a71808bcd6e8512abe46832be92f9ccdb">More...</a><br /></td></tr>
<tr class="separator:a71808bcd6e8512abe46832be92f9ccdb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07abd11965be32f2da970bb3d44e424c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classgamgee_1_1_variant_builder.html">VariantBuilder</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgamgee_1_1_variant_builder.html#a07abd11965be32f2da970bb3d44e424c">set_float_shared_field</a> (const std::string &amp;tag, const float value)</td></tr>
<tr class="memdesc:a07abd11965be32f2da970bb3d44e424c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a single-valued float shared field by field name.  <a href="#a07abd11965be32f2da970bb3d44e424c">More...</a><br /></td></tr>
<tr class="separator:a07abd11965be32f2da970bb3d44e424c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc6b8f4c1d727c116d9bf5d70cbbfda2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classgamgee_1_1_variant_builder.html">VariantBuilder</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgamgee_1_1_variant_builder.html#afc6b8f4c1d727c116d9bf5d70cbbfda2">set_float_shared_field</a> (const std::string &amp;tag, const std::vector&lt; float &gt; &amp;values)</td></tr>
<tr class="memdesc:afc6b8f4c1d727c116d9bf5d70cbbfda2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a multi-valued float shared field by field name.  <a href="#afc6b8f4c1d727c116d9bf5d70cbbfda2">More...</a><br /></td></tr>
<tr class="separator:afc6b8f4c1d727c116d9bf5d70cbbfda2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0e9e1be6fc88b1a2186326dc666a13c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classgamgee_1_1_variant_builder.html">VariantBuilder</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgamgee_1_1_variant_builder.html#af0e9e1be6fc88b1a2186326dc666a13c">set_float_shared_field</a> (const uint32_t index, const float value)</td></tr>
<tr class="memdesc:af0e9e1be6fc88b1a2186326dc666a13c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a single-valued float shared field by field index.  <a href="#af0e9e1be6fc88b1a2186326dc666a13c">More...</a><br /></td></tr>
<tr class="separator:af0e9e1be6fc88b1a2186326dc666a13c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35c6bfe5ed8f5f9313a14f3c417d0da9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classgamgee_1_1_variant_builder.html">VariantBuilder</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgamgee_1_1_variant_builder.html#a35c6bfe5ed8f5f9313a14f3c417d0da9">set_float_shared_field</a> (const uint32_t index, const std::vector&lt; float &gt; &amp;values)</td></tr>
<tr class="memdesc:a35c6bfe5ed8f5f9313a14f3c417d0da9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a multi-valued float shared field by field index.  <a href="#a35c6bfe5ed8f5f9313a14f3c417d0da9">More...</a><br /></td></tr>
<tr class="separator:a35c6bfe5ed8f5f9313a14f3c417d0da9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafc0bf24055d52a3278de0a366cf3554"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classgamgee_1_1_variant_builder.html">VariantBuilder</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgamgee_1_1_variant_builder.html#aafc0bf24055d52a3278de0a366cf3554">set_string_shared_field</a> (const std::string &amp;tag, const std::string &amp;value)</td></tr>
<tr class="memdesc:aafc0bf24055d52a3278de0a366cf3554"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a string shared field by field name.  <a href="#aafc0bf24055d52a3278de0a366cf3554">More...</a><br /></td></tr>
<tr class="separator:aafc0bf24055d52a3278de0a366cf3554"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00436fcaf17d72b1d61048195a50d8e7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classgamgee_1_1_variant_builder.html">VariantBuilder</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgamgee_1_1_variant_builder.html#a00436fcaf17d72b1d61048195a50d8e7">set_string_shared_field</a> (const uint32_t index, const std::string &amp;value)</td></tr>
<tr class="memdesc:a00436fcaf17d72b1d61048195a50d8e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a string shared field by field index.  <a href="#a00436fcaf17d72b1d61048195a50d8e7">More...</a><br /></td></tr>
<tr class="separator:a00436fcaf17d72b1d61048195a50d8e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ebd884661b9d03fbf9305d4329b0100"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classgamgee_1_1_variant_builder.html">VariantBuilder</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgamgee_1_1_variant_builder.html#a3ebd884661b9d03fbf9305d4329b0100">set_boolean_shared_field</a> (const std::string &amp;tag)</td></tr>
<tr class="memdesc:a3ebd884661b9d03fbf9305d4329b0100"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a boolean (flag) shared field by field name.  <a href="#a3ebd884661b9d03fbf9305d4329b0100">More...</a><br /></td></tr>
<tr class="separator:a3ebd884661b9d03fbf9305d4329b0100"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a7061bbc187d2720e09111deda13080"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classgamgee_1_1_variant_builder.html">VariantBuilder</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgamgee_1_1_variant_builder.html#a0a7061bbc187d2720e09111deda13080">set_boolean_shared_field</a> (const uint32_t index)</td></tr>
<tr class="memdesc:a0a7061bbc187d2720e09111deda13080"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a boolean (flag) shared field by field index.  <a href="#a0a7061bbc187d2720e09111deda13080">More...</a><br /></td></tr>
<tr class="separator:a0a7061bbc187d2720e09111deda13080"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8b0b7e5832fe47a51d3a90dec1a639b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classgamgee_1_1_variant_builder.html">VariantBuilder</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgamgee_1_1_variant_builder.html#af8b0b7e5832fe47a51d3a90dec1a639b">remove_shared_field</a> (const std::string &amp;tag)</td></tr>
<tr class="memdesc:af8b0b7e5832fe47a51d3a90dec1a639b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove a shared field by field name.  <a href="#af8b0b7e5832fe47a51d3a90dec1a639b">More...</a><br /></td></tr>
<tr class="separator:af8b0b7e5832fe47a51d3a90dec1a639b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53c4f9b8a2fc516d920ef0a4b6d5552a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classgamgee_1_1_variant_builder.html">VariantBuilder</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgamgee_1_1_variant_builder.html#a53c4f9b8a2fc516d920ef0a4b6d5552a">remove_shared_field</a> (const uint32_t field_index)</td></tr>
<tr class="memdesc:a53c4f9b8a2fc516d920ef0a4b6d5552a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove a shared field by field index.  <a href="#a53c4f9b8a2fc516d920ef0a4b6d5552a">More...</a><br /></td></tr>
<tr class="separator:a53c4f9b8a2fc516d920ef0a4b6d5552a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3999d10bdd6fba52c401edaf746bac2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classgamgee_1_1_variant_builder.html">VariantBuilder</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgamgee_1_1_variant_builder.html#aa3999d10bdd6fba52c401edaf746bac2">remove_shared_fields</a> (const std::vector&lt; std::string &gt; &amp;tags)</td></tr>
<tr class="memdesc:aa3999d10bdd6fba52c401edaf746bac2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove multiple shared fields by field name.  <a href="#aa3999d10bdd6fba52c401edaf746bac2">More...</a><br /></td></tr>
<tr class="separator:aa3999d10bdd6fba52c401edaf746bac2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2c2838f81febe53c64abb00138cd786"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classgamgee_1_1_variant_builder.html">VariantBuilder</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgamgee_1_1_variant_builder.html#ae2c2838f81febe53c64abb00138cd786">remove_shared_fields</a> (const std::vector&lt; uint32_t &gt; &amp;field_indices)</td></tr>
<tr class="memdesc:ae2c2838f81febe53c64abb00138cd786"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove multiple shared fields by field index.  <a href="#ae2c2838f81febe53c64abb00138cd786">More...</a><br /></td></tr>
<tr class="separator:ae2c2838f81febe53c64abb00138cd786"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d1a1436ac871c3ace750329e5ba74c8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classgamgee_1_1_variant_builder.html">VariantBuilder</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgamgee_1_1_variant_builder.html#a0d1a1436ac871c3ace750329e5ba74c8">set_genotypes</a> (const <a class="el" href="classgamgee_1_1_variant_builder_multi_sample_vector.html">VariantBuilderMultiSampleVector</a>&lt; int32_t &gt; &amp;genotypes_for_all_samples)</td></tr>
<tr class="memdesc:a0d1a1436ac871c3ace750329e5ba74c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the genotypes (GT) field for all samples at once using an efficient flattened (one-dimensional) vector, COPYING the provided values.  <a href="#a0d1a1436ac871c3ace750329e5ba74c8">More...</a><br /></td></tr>
<tr class="separator:a0d1a1436ac871c3ace750329e5ba74c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada19d70b1b04effa3dae32c1ee9a01a2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classgamgee_1_1_variant_builder.html">VariantBuilder</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgamgee_1_1_variant_builder.html#ada19d70b1b04effa3dae32c1ee9a01a2">set_genotypes</a> (<a class="el" href="classgamgee_1_1_variant_builder_multi_sample_vector.html">VariantBuilderMultiSampleVector</a>&lt; int32_t &gt; &amp;&amp;genotypes_for_all_samples)</td></tr>
<tr class="memdesc:ada19d70b1b04effa3dae32c1ee9a01a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the genotypes (GT) field for all samples at once using an efficient flattened (one-dimensional) vector, MOVING the provided values.  <a href="#ada19d70b1b04effa3dae32c1ee9a01a2">More...</a><br /></td></tr>
<tr class="separator:ada19d70b1b04effa3dae32c1ee9a01a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb2c97a4caccae8487520df149a7ef52"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classgamgee_1_1_variant_builder.html">VariantBuilder</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgamgee_1_1_variant_builder.html#afb2c97a4caccae8487520df149a7ef52">set_genotypes</a> (const std::vector&lt; std::vector&lt; int32_t &gt;&gt; &amp;genotypes_for_all_samples)</td></tr>
<tr class="memdesc:afb2c97a4caccae8487520df149a7ef52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the genotypes (GT) field for all samples at once by nested vector, COPYING the provided values.  <a href="#afb2c97a4caccae8487520df149a7ef52">More...</a><br /></td></tr>
<tr class="separator:afb2c97a4caccae8487520df149a7ef52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa4697cf3394eafe427fed6d17a7a174"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classgamgee_1_1_variant_builder.html">VariantBuilder</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgamgee_1_1_variant_builder.html#afa4697cf3394eafe427fed6d17a7a174">set_genotypes</a> (std::vector&lt; std::vector&lt; int32_t &gt;&gt; &amp;&amp;genotypes_for_all_samples)</td></tr>
<tr class="memdesc:afa4697cf3394eafe427fed6d17a7a174"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the genotypes (GT) field for all samples at once by nested vector, MOVING the provided values.  <a href="#afa4697cf3394eafe427fed6d17a7a174">More...</a><br /></td></tr>
<tr class="separator:afa4697cf3394eafe427fed6d17a7a174"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab39b8ab240ea63afd5fd69309c9c6bac"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classgamgee_1_1_variant_builder.html">VariantBuilder</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgamgee_1_1_variant_builder.html#ab39b8ab240ea63afd5fd69309c9c6bac">set_integer_individual_field</a> (const std::string &amp;tag, const <a class="el" href="classgamgee_1_1_variant_builder_multi_sample_vector.html">VariantBuilderMultiSampleVector</a>&lt; int32_t &gt; &amp;values_for_all_samples)</td></tr>
<tr class="memdesc:ab39b8ab240ea63afd5fd69309c9c6bac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set an integer individual field for all samples at once by name using an efficient flattened (one-dimensional) vector, COPYING the provided values.  <a href="#ab39b8ab240ea63afd5fd69309c9c6bac">More...</a><br /></td></tr>
<tr class="separator:ab39b8ab240ea63afd5fd69309c9c6bac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ec4c931c83314e9c8b7e4d51dd3c1a7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classgamgee_1_1_variant_builder.html">VariantBuilder</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgamgee_1_1_variant_builder.html#a3ec4c931c83314e9c8b7e4d51dd3c1a7">set_integer_individual_field</a> (const std::string &amp;tag, <a class="el" href="classgamgee_1_1_variant_builder_multi_sample_vector.html">VariantBuilderMultiSampleVector</a>&lt; int32_t &gt; &amp;&amp;values_for_all_samples)</td></tr>
<tr class="memdesc:a3ec4c931c83314e9c8b7e4d51dd3c1a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set an integer individual field for all samples at once by name using an efficient flattened (one-dimensional) vector, MOVING the provided values.  <a href="#a3ec4c931c83314e9c8b7e4d51dd3c1a7">More...</a><br /></td></tr>
<tr class="separator:a3ec4c931c83314e9c8b7e4d51dd3c1a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbdb45675372b4918a6895b692c35484"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classgamgee_1_1_variant_builder.html">VariantBuilder</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgamgee_1_1_variant_builder.html#afbdb45675372b4918a6895b692c35484">set_integer_individual_field</a> (const std::string &amp;tag, const std::vector&lt; std::vector&lt; int32_t &gt;&gt; &amp;values_for_all_samples)</td></tr>
<tr class="memdesc:afbdb45675372b4918a6895b692c35484"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set an integer individual field for all samples at once by name using a nested vector, copying the provided values.  <a href="#afbdb45675372b4918a6895b692c35484">More...</a><br /></td></tr>
<tr class="separator:afbdb45675372b4918a6895b692c35484"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d5f04cb707449afba36a2224aa8f0d0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classgamgee_1_1_variant_builder.html">VariantBuilder</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgamgee_1_1_variant_builder.html#a3d5f04cb707449afba36a2224aa8f0d0">set_integer_individual_field</a> (const std::string &amp;tag, std::vector&lt; std::vector&lt; int32_t &gt;&gt; &amp;&amp;values_for_all_samples)</td></tr>
<tr class="memdesc:a3d5f04cb707449afba36a2224aa8f0d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set an integer individual field for all samples at once by name using a nested vector, moving the provided values.  <a href="#a3d5f04cb707449afba36a2224aa8f0d0">More...</a><br /></td></tr>
<tr class="separator:a3d5f04cb707449afba36a2224aa8f0d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f48625de1d221b26175176b84f26431"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classgamgee_1_1_variant_builder.html">VariantBuilder</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgamgee_1_1_variant_builder.html#a4f48625de1d221b26175176b84f26431">set_integer_individual_field</a> (const uint32_t field_index, const <a class="el" href="classgamgee_1_1_variant_builder_multi_sample_vector.html">VariantBuilderMultiSampleVector</a>&lt; int32_t &gt; &amp;values_for_all_samples)</td></tr>
<tr class="memdesc:a4f48625de1d221b26175176b84f26431"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set an integer individual field for all samples at once by index using an efficient flattened (one-dimensional) vector, COPYING the provided values.  <a href="#a4f48625de1d221b26175176b84f26431">More...</a><br /></td></tr>
<tr class="separator:a4f48625de1d221b26175176b84f26431"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfc0eb4c39f5c09297508420ea715d58"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classgamgee_1_1_variant_builder.html">VariantBuilder</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgamgee_1_1_variant_builder.html#adfc0eb4c39f5c09297508420ea715d58">set_integer_individual_field</a> (const uint32_t field_index, <a class="el" href="classgamgee_1_1_variant_builder_multi_sample_vector.html">VariantBuilderMultiSampleVector</a>&lt; int32_t &gt; &amp;&amp;values_for_all_samples)</td></tr>
<tr class="memdesc:adfc0eb4c39f5c09297508420ea715d58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set an integer individual field for all samples at once by index using an efficient flattened (one-dimensional) vector, MOVING the provided values.  <a href="#adfc0eb4c39f5c09297508420ea715d58">More...</a><br /></td></tr>
<tr class="separator:adfc0eb4c39f5c09297508420ea715d58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b5df29223c21d13cfcc397a9a4c91e0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classgamgee_1_1_variant_builder.html">VariantBuilder</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgamgee_1_1_variant_builder.html#a3b5df29223c21d13cfcc397a9a4c91e0">set_integer_individual_field</a> (const uint32_t field_index, const std::vector&lt; std::vector&lt; int32_t &gt;&gt; &amp;values_for_all_samples)</td></tr>
<tr class="memdesc:a3b5df29223c21d13cfcc397a9a4c91e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set an integer individual field for all samples at once by index using a nested vector, copying the provided values.  <a href="#a3b5df29223c21d13cfcc397a9a4c91e0">More...</a><br /></td></tr>
<tr class="separator:a3b5df29223c21d13cfcc397a9a4c91e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae961d5aa85bed381ae45794c45c2cdc1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classgamgee_1_1_variant_builder.html">VariantBuilder</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgamgee_1_1_variant_builder.html#ae961d5aa85bed381ae45794c45c2cdc1">set_integer_individual_field</a> (const uint32_t field_index, std::vector&lt; std::vector&lt; int32_t &gt;&gt; &amp;&amp;values_for_all_samples)</td></tr>
<tr class="memdesc:ae961d5aa85bed381ae45794c45c2cdc1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set an integer individual field for all samples at once by index using a nested vector, moving the provided values.  <a href="#ae961d5aa85bed381ae45794c45c2cdc1">More...</a><br /></td></tr>
<tr class="separator:ae961d5aa85bed381ae45794c45c2cdc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a23a09aa081ebf2171337077feb8e63"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classgamgee_1_1_variant_builder.html">VariantBuilder</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgamgee_1_1_variant_builder.html#a7a23a09aa081ebf2171337077feb8e63">set_float_individual_field</a> (const std::string &amp;tag, const <a class="el" href="classgamgee_1_1_variant_builder_multi_sample_vector.html">VariantBuilderMultiSampleVector</a>&lt; float &gt; &amp;values_for_all_samples)</td></tr>
<tr class="memdesc:a7a23a09aa081ebf2171337077feb8e63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a float individual field for all samples at once by name using an efficient flattened (one-dimensional) vector, COPYING the provided values.  <a href="#a7a23a09aa081ebf2171337077feb8e63">More...</a><br /></td></tr>
<tr class="separator:a7a23a09aa081ebf2171337077feb8e63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ab5688fb53a51951674bd51fd09bfde"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classgamgee_1_1_variant_builder.html">VariantBuilder</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgamgee_1_1_variant_builder.html#a5ab5688fb53a51951674bd51fd09bfde">set_float_individual_field</a> (const std::string &amp;tag, <a class="el" href="classgamgee_1_1_variant_builder_multi_sample_vector.html">VariantBuilderMultiSampleVector</a>&lt; float &gt; &amp;&amp;values_for_all_samples)</td></tr>
<tr class="memdesc:a5ab5688fb53a51951674bd51fd09bfde"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a float individual field for all samples at once by name using an efficient flattened (one-dimensional) vector, MOVING the provided values.  <a href="#a5ab5688fb53a51951674bd51fd09bfde">More...</a><br /></td></tr>
<tr class="separator:a5ab5688fb53a51951674bd51fd09bfde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3495cfd6e141aa92919277bee5a3889"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classgamgee_1_1_variant_builder.html">VariantBuilder</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgamgee_1_1_variant_builder.html#ad3495cfd6e141aa92919277bee5a3889">set_float_individual_field</a> (const std::string &amp;tag, const std::vector&lt; std::vector&lt; float &gt;&gt; &amp;values_for_all_samples)</td></tr>
<tr class="memdesc:ad3495cfd6e141aa92919277bee5a3889"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a float individual field for all samples at once by name using a nested vector, copying the provided values.  <a href="#ad3495cfd6e141aa92919277bee5a3889">More...</a><br /></td></tr>
<tr class="separator:ad3495cfd6e141aa92919277bee5a3889"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e14a944b1b174bbdac63890b0f820ce"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classgamgee_1_1_variant_builder.html">VariantBuilder</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgamgee_1_1_variant_builder.html#a3e14a944b1b174bbdac63890b0f820ce">set_float_individual_field</a> (const std::string &amp;tag, std::vector&lt; std::vector&lt; float &gt;&gt; &amp;&amp;values_for_all_samples)</td></tr>
<tr class="memdesc:a3e14a944b1b174bbdac63890b0f820ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a float individual field for all samples at once by name using a nested vector, moving the provided values.  <a href="#a3e14a944b1b174bbdac63890b0f820ce">More...</a><br /></td></tr>
<tr class="separator:a3e14a944b1b174bbdac63890b0f820ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a754d950816e0bcb7a018cfbf4f6e7f9c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classgamgee_1_1_variant_builder.html">VariantBuilder</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgamgee_1_1_variant_builder.html#a754d950816e0bcb7a018cfbf4f6e7f9c">set_float_individual_field</a> (const uint32_t field_index, const <a class="el" href="classgamgee_1_1_variant_builder_multi_sample_vector.html">VariantBuilderMultiSampleVector</a>&lt; float &gt; &amp;values_for_all_samples)</td></tr>
<tr class="memdesc:a754d950816e0bcb7a018cfbf4f6e7f9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a float individual field for all samples at once by index using an efficient flattened (one-dimensional) vector, COPYING the provided values.  <a href="#a754d950816e0bcb7a018cfbf4f6e7f9c">More...</a><br /></td></tr>
<tr class="separator:a754d950816e0bcb7a018cfbf4f6e7f9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91e44b54c59fbc7ddf8fb2155c5b53f3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classgamgee_1_1_variant_builder.html">VariantBuilder</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgamgee_1_1_variant_builder.html#a91e44b54c59fbc7ddf8fb2155c5b53f3">set_float_individual_field</a> (const uint32_t field_index, <a class="el" href="classgamgee_1_1_variant_builder_multi_sample_vector.html">VariantBuilderMultiSampleVector</a>&lt; float &gt; &amp;&amp;values_for_all_samples)</td></tr>
<tr class="memdesc:a91e44b54c59fbc7ddf8fb2155c5b53f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a float individual field for all samples at once by index using an efficient flattened (one-dimensional) vector, MOVING the provided values.  <a href="#a91e44b54c59fbc7ddf8fb2155c5b53f3">More...</a><br /></td></tr>
<tr class="separator:a91e44b54c59fbc7ddf8fb2155c5b53f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a2e781f73831057f13a3e3a6433cf82"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classgamgee_1_1_variant_builder.html">VariantBuilder</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgamgee_1_1_variant_builder.html#a7a2e781f73831057f13a3e3a6433cf82">set_float_individual_field</a> (const uint32_t field_index, const std::vector&lt; std::vector&lt; float &gt;&gt; &amp;values_for_all_samples)</td></tr>
<tr class="memdesc:a7a2e781f73831057f13a3e3a6433cf82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a float individual field for all samples at once by index using a nested vector, copying the provided values.  <a href="#a7a2e781f73831057f13a3e3a6433cf82">More...</a><br /></td></tr>
<tr class="separator:a7a2e781f73831057f13a3e3a6433cf82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb7e4ac0f78573ab68d16dd00bffb144"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classgamgee_1_1_variant_builder.html">VariantBuilder</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgamgee_1_1_variant_builder.html#adb7e4ac0f78573ab68d16dd00bffb144">set_float_individual_field</a> (const uint32_t field_index, std::vector&lt; std::vector&lt; float &gt;&gt; &amp;&amp;values_for_all_samples)</td></tr>
<tr class="memdesc:adb7e4ac0f78573ab68d16dd00bffb144"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a float individual field for all samples at once by index using a nested vector, moving the provided values.  <a href="#adb7e4ac0f78573ab68d16dd00bffb144">More...</a><br /></td></tr>
<tr class="separator:adb7e4ac0f78573ab68d16dd00bffb144"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a395ac9f569128804788c00d8402ab065"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classgamgee_1_1_variant_builder.html">VariantBuilder</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgamgee_1_1_variant_builder.html#a395ac9f569128804788c00d8402ab065">set_string_individual_field</a> (const std::string &amp;tag, const std::vector&lt; std::string &gt; &amp;values_for_all_samples)</td></tr>
<tr class="memdesc:a395ac9f569128804788c00d8402ab065"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a string individual field for all samples at once by name, copying the provided values.  <a href="#a395ac9f569128804788c00d8402ab065">More...</a><br /></td></tr>
<tr class="separator:a395ac9f569128804788c00d8402ab065"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94814cb21e8f545b674fc53e0c92d834"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classgamgee_1_1_variant_builder.html">VariantBuilder</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgamgee_1_1_variant_builder.html#a94814cb21e8f545b674fc53e0c92d834">set_string_individual_field</a> (const std::string &amp;tag, std::vector&lt; std::string &gt; &amp;&amp;values_for_all_samples)</td></tr>
<tr class="memdesc:a94814cb21e8f545b674fc53e0c92d834"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a string individual field for all samples at once by name, moving the provided values.  <a href="#a94814cb21e8f545b674fc53e0c92d834">More...</a><br /></td></tr>
<tr class="separator:a94814cb21e8f545b674fc53e0c92d834"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a524e519089e1a40ae9a69e52a00b338d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classgamgee_1_1_variant_builder.html">VariantBuilder</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgamgee_1_1_variant_builder.html#a524e519089e1a40ae9a69e52a00b338d">set_string_individual_field</a> (const uint32_t field_index, const std::vector&lt; std::string &gt; &amp;values_for_all_samples)</td></tr>
<tr class="memdesc:a524e519089e1a40ae9a69e52a00b338d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a string individual field for all samples at once by index, copying the provided values.  <a href="#a524e519089e1a40ae9a69e52a00b338d">More...</a><br /></td></tr>
<tr class="separator:a524e519089e1a40ae9a69e52a00b338d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab4c859786c762e8c8a91e61bbaf8cfa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classgamgee_1_1_variant_builder.html">VariantBuilder</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgamgee_1_1_variant_builder.html#aab4c859786c762e8c8a91e61bbaf8cfa">set_string_individual_field</a> (const uint32_t field_index, std::vector&lt; std::string &gt; &amp;&amp;values_for_all_samples)</td></tr>
<tr class="memdesc:aab4c859786c762e8c8a91e61bbaf8cfa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a string individual field for all samples at once by index, moving the provided values.  <a href="#aab4c859786c762e8c8a91e61bbaf8cfa">More...</a><br /></td></tr>
<tr class="separator:aab4c859786c762e8c8a91e61bbaf8cfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8fe52db4cc7f67fabd8a91610de9eaa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classgamgee_1_1_variant_builder.html">VariantBuilder</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgamgee_1_1_variant_builder.html#ab8fe52db4cc7f67fabd8a91610de9eaa">set_genotype</a> (const std::string &amp;sample, const std::vector&lt; int32_t &gt; &amp;genotype)</td></tr>
<tr class="memdesc:ab8fe52db4cc7f67fabd8a91610de9eaa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the genotypes (GT) field for a single sample by sample name, copying the genotype before encoding.  <a href="#ab8fe52db4cc7f67fabd8a91610de9eaa">More...</a><br /></td></tr>
<tr class="separator:ab8fe52db4cc7f67fabd8a91610de9eaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af64883ed26f97f9471b591b8bc400b2b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classgamgee_1_1_variant_builder.html">VariantBuilder</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgamgee_1_1_variant_builder.html#af64883ed26f97f9471b591b8bc400b2b">set_genotype</a> (const std::string &amp;sample, std::vector&lt; int32_t &gt; &amp;&amp;genotype)</td></tr>
<tr class="memdesc:af64883ed26f97f9471b591b8bc400b2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the genotypes (GT) field for a single sample by sample name, moving the genotype into the builder and encoding in-place.  <a href="#af64883ed26f97f9471b591b8bc400b2b">More...</a><br /></td></tr>
<tr class="separator:af64883ed26f97f9471b591b8bc400b2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7998a9347ae72b97a607c6773a23f08"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classgamgee_1_1_variant_builder.html">VariantBuilder</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgamgee_1_1_variant_builder.html#ac7998a9347ae72b97a607c6773a23f08">set_genotype</a> (const uint32_t sample_index, const std::vector&lt; int32_t &gt; &amp;genotype)</td></tr>
<tr class="memdesc:ac7998a9347ae72b97a607c6773a23f08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the genotypes (GT) field for a single sample by sample index, copying the genotype before encoding.  <a href="#ac7998a9347ae72b97a607c6773a23f08">More...</a><br /></td></tr>
<tr class="separator:ac7998a9347ae72b97a607c6773a23f08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ff527e8ac6e0c5c19e2c3c372e67281"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classgamgee_1_1_variant_builder.html">VariantBuilder</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgamgee_1_1_variant_builder.html#a9ff527e8ac6e0c5c19e2c3c372e67281">set_genotype</a> (const uint32_t sample_index, std::vector&lt; int32_t &gt; &amp;&amp;genotype)</td></tr>
<tr class="memdesc:a9ff527e8ac6e0c5c19e2c3c372e67281"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the genotypes (GT) field for a single sample by sample index, moving the genotype into the builder and encoding in-place.  <a href="#a9ff527e8ac6e0c5c19e2c3c372e67281">More...</a><br /></td></tr>
<tr class="separator:a9ff527e8ac6e0c5c19e2c3c372e67281"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6910634a94d22b99b9f5180f128af6b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classgamgee_1_1_variant_builder.html">VariantBuilder</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgamgee_1_1_variant_builder.html#af6910634a94d22b99b9f5180f128af6b">set_integer_individual_field</a> (const std::string &amp;tag, const std::string &amp;sample, const int32_t value)</td></tr>
<tr class="memdesc:af6910634a94d22b99b9f5180f128af6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a single-valued integer individual field for a single sample by field and sample name.  <a href="#af6910634a94d22b99b9f5180f128af6b">More...</a><br /></td></tr>
<tr class="separator:af6910634a94d22b99b9f5180f128af6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33e4dfd32226cc8f1a378f421ccdf4f9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classgamgee_1_1_variant_builder.html">VariantBuilder</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgamgee_1_1_variant_builder.html#a33e4dfd32226cc8f1a378f421ccdf4f9">set_integer_individual_field</a> (const std::string &amp;tag, const std::string &amp;sample, const std::vector&lt; int32_t &gt; &amp;values)</td></tr>
<tr class="memdesc:a33e4dfd32226cc8f1a378f421ccdf4f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a multi-valued integer individual field for a single sample by field and sample name.  <a href="#a33e4dfd32226cc8f1a378f421ccdf4f9">More...</a><br /></td></tr>
<tr class="separator:a33e4dfd32226cc8f1a378f421ccdf4f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb6dbd3f1cc5ef9669ca1c691d0e2b4f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classgamgee_1_1_variant_builder.html">VariantBuilder</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgamgee_1_1_variant_builder.html#abb6dbd3f1cc5ef9669ca1c691d0e2b4f">set_integer_individual_field</a> (const uint32_t field_index, const uint32_t sample_index, const int32_t value)</td></tr>
<tr class="memdesc:abb6dbd3f1cc5ef9669ca1c691d0e2b4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a single-valued integer individual field for a single sample by field and sample index.  <a href="#abb6dbd3f1cc5ef9669ca1c691d0e2b4f">More...</a><br /></td></tr>
<tr class="separator:abb6dbd3f1cc5ef9669ca1c691d0e2b4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a721fca52e1a7228cbf390354e088e72c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classgamgee_1_1_variant_builder.html">VariantBuilder</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgamgee_1_1_variant_builder.html#a721fca52e1a7228cbf390354e088e72c">set_integer_individual_field</a> (const uint32_t field_index, const uint32_t sample_index, const std::vector&lt; int32_t &gt; &amp;values)</td></tr>
<tr class="memdesc:a721fca52e1a7228cbf390354e088e72c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a multi-valued integer individual field for a single sample by field and sample index.  <a href="#a721fca52e1a7228cbf390354e088e72c">More...</a><br /></td></tr>
<tr class="separator:a721fca52e1a7228cbf390354e088e72c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0ce5bf2a9fab384beb546f8e4fdb532"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classgamgee_1_1_variant_builder.html">VariantBuilder</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgamgee_1_1_variant_builder.html#aa0ce5bf2a9fab384beb546f8e4fdb532">set_float_individual_field</a> (const std::string &amp;tag, const std::string &amp;sample, const float value)</td></tr>
<tr class="memdesc:aa0ce5bf2a9fab384beb546f8e4fdb532"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a single-valued float individual field for a single sample by field and sample name.  <a href="#aa0ce5bf2a9fab384beb546f8e4fdb532">More...</a><br /></td></tr>
<tr class="separator:aa0ce5bf2a9fab384beb546f8e4fdb532"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbfd4576c6477c3088d1b53e603d5d26"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classgamgee_1_1_variant_builder.html">VariantBuilder</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgamgee_1_1_variant_builder.html#afbfd4576c6477c3088d1b53e603d5d26">set_float_individual_field</a> (const std::string &amp;tag, const std::string &amp;sample, const std::vector&lt; float &gt; &amp;values)</td></tr>
<tr class="memdesc:afbfd4576c6477c3088d1b53e603d5d26"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a multi-valued float individual field for a single sample by field and sample name.  <a href="#afbfd4576c6477c3088d1b53e603d5d26">More...</a><br /></td></tr>
<tr class="separator:afbfd4576c6477c3088d1b53e603d5d26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1557ea3f4a29ce96495c6cd8795abb52"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classgamgee_1_1_variant_builder.html">VariantBuilder</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgamgee_1_1_variant_builder.html#a1557ea3f4a29ce96495c6cd8795abb52">set_float_individual_field</a> (const uint32_t field_index, const uint32_t sample_index, const float value)</td></tr>
<tr class="memdesc:a1557ea3f4a29ce96495c6cd8795abb52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a single-valued float individual field for a single sample by field and sample index.  <a href="#a1557ea3f4a29ce96495c6cd8795abb52">More...</a><br /></td></tr>
<tr class="separator:a1557ea3f4a29ce96495c6cd8795abb52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33fb12a456b9adfeb5fabe2934bae940"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classgamgee_1_1_variant_builder.html">VariantBuilder</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgamgee_1_1_variant_builder.html#a33fb12a456b9adfeb5fabe2934bae940">set_float_individual_field</a> (const uint32_t field_index, const uint32_t sample_index, const std::vector&lt; float &gt; &amp;values)</td></tr>
<tr class="memdesc:a33fb12a456b9adfeb5fabe2934bae940"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a multi-valued float individual field for a single sample by field and sample index.  <a href="#a33fb12a456b9adfeb5fabe2934bae940">More...</a><br /></td></tr>
<tr class="separator:a33fb12a456b9adfeb5fabe2934bae940"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e07de72742b9cc9e7b0743886ad7dea"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classgamgee_1_1_variant_builder.html">VariantBuilder</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgamgee_1_1_variant_builder.html#a7e07de72742b9cc9e7b0743886ad7dea">set_string_individual_field</a> (const std::string &amp;tag, const std::string &amp;sample, const std::string &amp;value)</td></tr>
<tr class="memdesc:a7e07de72742b9cc9e7b0743886ad7dea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a string individual field for a single sample by field and sample name.  <a href="#a7e07de72742b9cc9e7b0743886ad7dea">More...</a><br /></td></tr>
<tr class="separator:a7e07de72742b9cc9e7b0743886ad7dea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93e57465db044273b3dc1ed9d843497b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classgamgee_1_1_variant_builder.html">VariantBuilder</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgamgee_1_1_variant_builder.html#a93e57465db044273b3dc1ed9d843497b">set_string_individual_field</a> (const uint32_t field_index, const uint32_t sample_index, const std::string &amp;value)</td></tr>
<tr class="memdesc:a93e57465db044273b3dc1ed9d843497b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a string individual field for a single sample by field and sample index.  <a href="#a93e57465db044273b3dc1ed9d843497b">More...</a><br /></td></tr>
<tr class="separator:a93e57465db044273b3dc1ed9d843497b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e868c51ef47d83910811eb5d9906549"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classgamgee_1_1_variant_builder.html">VariantBuilder</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgamgee_1_1_variant_builder.html#a0e868c51ef47d83910811eb5d9906549">remove_individual_field</a> (const std::string &amp;tag)</td></tr>
<tr class="memdesc:a0e868c51ef47d83910811eb5d9906549"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove an individual field by field name.  <a href="#a0e868c51ef47d83910811eb5d9906549">More...</a><br /></td></tr>
<tr class="separator:a0e868c51ef47d83910811eb5d9906549"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72303ecbab803da346641df7462f7ee0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classgamgee_1_1_variant_builder.html">VariantBuilder</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgamgee_1_1_variant_builder.html#a72303ecbab803da346641df7462f7ee0">remove_individual_field</a> (const uint32_t field_index)</td></tr>
<tr class="memdesc:a72303ecbab803da346641df7462f7ee0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove an individual field by field index.  <a href="#a72303ecbab803da346641df7462f7ee0">More...</a><br /></td></tr>
<tr class="separator:a72303ecbab803da346641df7462f7ee0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace7220abe7a8471b366f59be247c919b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classgamgee_1_1_variant_builder.html">VariantBuilder</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgamgee_1_1_variant_builder.html#ace7220abe7a8471b366f59be247c919b">remove_individual_fields</a> (const std::vector&lt; std::string &gt; &amp;tags)</td></tr>
<tr class="memdesc:ace7220abe7a8471b366f59be247c919b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove multiple individual fields by field name.  <a href="#ace7220abe7a8471b366f59be247c919b">More...</a><br /></td></tr>
<tr class="separator:ace7220abe7a8471b366f59be247c919b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc19a0d513d8ef0a83931fb02214bc0b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classgamgee_1_1_variant_builder.html">VariantBuilder</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgamgee_1_1_variant_builder.html#adc19a0d513d8ef0a83931fb02214bc0b">remove_individual_fields</a> (const std::vector&lt; uint32_t &gt; &amp;field_indices)</td></tr>
<tr class="memdesc:adc19a0d513d8ef0a83931fb02214bc0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove multiple individual fields by field index.  <a href="#adc19a0d513d8ef0a83931fb02214bc0b">More...</a><br /></td></tr>
<tr class="separator:adc19a0d513d8ef0a83931fb02214bc0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84a13b9951eeaeb4e28bfb42c94d785b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classgamgee_1_1_variant_builder_multi_sample_vector.html">VariantBuilderMultiSampleVector</a><br class="typebreak" />
&lt; int32_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgamgee_1_1_variant_builder.html#a84a13b9951eeaeb4e28bfb42c94d785b">get_genotype_multi_sample_vector</a> (const uint32_t num_samples, const uint32_t max_values_per_sample) const </td></tr>
<tr class="memdesc:a84a13b9951eeaeb4e28bfb42c94d785b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a pre-initialized/padded <a class="el" href="classgamgee_1_1_variant_builder_multi_sample_vector.html" title="Class that allows you to efficiently prepare multi-sample data for setting individual fields in Varia...">VariantBuilderMultiSampleVector</a> for use with the more-efficient GT field bulk setters.  <a href="#a84a13b9951eeaeb4e28bfb42c94d785b">More...</a><br /></td></tr>
<tr class="separator:a84a13b9951eeaeb4e28bfb42c94d785b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1be11bfcf550d80d7015d7b2aaed0705"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classgamgee_1_1_variant_builder_multi_sample_vector.html">VariantBuilderMultiSampleVector</a><br class="typebreak" />
&lt; int32_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgamgee_1_1_variant_builder.html#a1be11bfcf550d80d7015d7b2aaed0705">get_integer_multi_sample_vector</a> (const uint32_t num_samples, const uint32_t max_values_per_sample) const </td></tr>
<tr class="memdesc:a1be11bfcf550d80d7015d7b2aaed0705"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a pre-initialized/padded <a class="el" href="classgamgee_1_1_variant_builder_multi_sample_vector.html" title="Class that allows you to efficiently prepare multi-sample data for setting individual fields in Varia...">VariantBuilderMultiSampleVector</a> for use with the more-efficient integer individual field bulk setters.  <a href="#a1be11bfcf550d80d7015d7b2aaed0705">More...</a><br /></td></tr>
<tr class="separator:a1be11bfcf550d80d7015d7b2aaed0705"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59728859808bb0e43b285688e58e4e37"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classgamgee_1_1_variant_builder_multi_sample_vector.html">VariantBuilderMultiSampleVector</a><br class="typebreak" />
&lt; float &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgamgee_1_1_variant_builder.html#a59728859808bb0e43b285688e58e4e37">get_float_multi_sample_vector</a> (const uint32_t num_samples, const uint32_t max_values_per_sample) const </td></tr>
<tr class="memdesc:a59728859808bb0e43b285688e58e4e37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a pre-initialized/padded <a class="el" href="classgamgee_1_1_variant_builder_multi_sample_vector.html" title="Class that allows you to efficiently prepare multi-sample data for setting individual fields in Varia...">VariantBuilderMultiSampleVector</a> for use with the more-efficient float individual field bulk setters.  <a href="#a59728859808bb0e43b285688e58e4e37">More...</a><br /></td></tr>
<tr class="separator:a59728859808bb0e43b285688e58e4e37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9af2780b3ef03762f437b435cf277a65"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classgamgee_1_1_variant.html">Variant</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgamgee_1_1_variant_builder.html#a9af2780b3ef03762f437b435cf277a65">build</a> () const </td></tr>
<tr class="memdesc:a9af2780b3ef03762f437b435cf277a65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new <a class="el" href="classgamgee_1_1_variant.html" title="Utility class to manipulate a Variant record. ">Variant</a> record using the current state of the builder.  <a href="#a9af2780b3ef03762f437b435cf277a65">More...</a><br /></td></tr>
<tr class="separator:a9af2780b3ef03762f437b435cf277a65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae53a85c2274e8af69098176451aa4ac5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classgamgee_1_1_variant_builder.html">VariantBuilder</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgamgee_1_1_variant_builder.html#ae53a85c2274e8af69098176451aa4ac5">clear</a> ()</td></tr>
<tr class="memdesc:ae53a85c2274e8af69098176451aa4ac5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear all field values in this builder to prepare it for the next build operation.  <a href="#ae53a85c2274e8af69098176451aa4ac5">More...</a><br /></td></tr>
<tr class="separator:ae53a85c2274e8af69098176451aa4ac5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p><a class="el" href="classgamgee_1_1_variant_builder.html" title="VariantBuilder: construct Variant records from scratch (and, coming soon, from existing Variant recor...">VariantBuilder</a>: construct <a class="el" href="classgamgee_1_1_variant.html" title="Utility class to manipulate a Variant record. ">Variant</a> records from scratch (and, coming soon, from existing <a class="el" href="classgamgee_1_1_variant.html" title="Utility class to manipulate a Variant record. ">Variant</a> records) </p>
<p>To use, first create a <a class="el" href="classgamgee_1_1_variant_header.html" title="Utility class to hold a variant header. ">VariantHeader</a> appropriate for the final record(s) you intend to create (with all shared/individual fields, samples, and contigs pre-declared), then use that header to instantiate a builder:</p>
<p>auto builder = <a class="el" href="classgamgee_1_1_variant_builder.html" title="VariantBuilder: construct Variant records from scratch (and, coming soon, from existing Variant recor...">VariantBuilder</a>{header};</p>
<p>You should create ONE builder per file you intend to output, and re-use it across records, calling <a class="el" href="classgamgee_1_1_variant_builder.html#ae53a85c2274e8af69098176451aa4ac5" title="Clear all field values in this builder to prepare it for the next build operation. ">clear()</a> in between each record. Do NOT create a new builder for each record &ndash; creating/destroying builders is an expensive process involving many memory allocations and deallocations of internal data structures as well as costly header lookups. Ie., the correct way to use a builder is:</p>
<p>auto builder = <a class="el" href="classgamgee_1_1_variant_builder.html" title="VariantBuilder: construct Variant records from scratch (and, coming soon, from existing Variant recor...">VariantBuilder</a>{header}; for ( each record you want to create ) { // use existing builder to build new record builder.clear(); }</p>
<p>Once you have a builder you can call setter functions in a chained fashion as follows:</p>
<p>auto variant = builder.set_chromosome(0).set_alignment_start(5).set_ref_allele("A") .set_alt_alleles({"C", "T"}).set_genotypes(std::move(my_genotypes)) .<a class="el" href="classgamgee_1_1_variant_builder.html#a9af2780b3ef03762f437b435cf277a65" title="Create a new Variant record using the current state of the builder. ">build()</a>;</p>
<p>See the comments further down for instructions and tips on using the various kinds of setters.</p>
<p>You must at a minimum set the required chromosome, alignment start, and ref allele fields (unless you have disabled validation, but then you will just get an invalid <a class="el" href="classgamgee_1_1_variant.html" title="Utility class to manipulate a Variant record. ">Variant</a> record).</p>
<p>The <a class="el" href="classgamgee_1_1_variant_builder.html" title="VariantBuilder: construct Variant records from scratch (and, coming soon, from existing Variant recor...">VariantBuilder</a> API is designed to allow you to be efficient when you want to be (eg., moving existing data into the builder, setting individual fields in bulk rather than by sample, etc.), and lazy when you don't care about efficiency. In general, the more efficient API functions require a bit more work to use than the less efficient ones. See the discussions below of the efficiency of the various options available to you for setting fields.</p>
<h2>Some general guidelines: </h2>
<p>-Setting by field/sample index is more efficient than setting by field/sample name, provided that you look up the index for each field/sample ONCE in the header and cache it at traversal start instead of looking it up for every record.</p>
<p>-For setting single-valued fields it's more efficient to use the functions that take a scalar value (int, float, etc.) instead of a vector.</p>
<p>-For removing fields you generally have the option of either calling the appropriate remove_* API function, OR passing in a missing/empty value to the appropriate set_* function. Both options are equivalent and will result in the field being removed.</p>
<p>-Disabling validation is possible, and will certainly improve performance, however if you attempt to perform an action that would have been prevented by validation checks (such as setting a non-existent field) you WILL get undefined behavior in your program. You should ONLY disable validation if you're extremely confident that your program will not take any invalid/incorrect actions, and that the data you pass to the builder will always be valid.</p>
<h2>Notes on setting individual fields: </h2>
<p>-Setting individual fields by move/r-value is more efficient than setting by l-value, as the functions that take an l-value reference assume that you want to keep your data and therefore make a copy of it. Note that you will usually have to invoke std::move() explicitly to avoid a copy &ndash; eg., </p><pre class="fragment">builder.set_integer_individual_field(field_index, std::move(my_vector));
</pre><p>-Setting individual fields in bulk (ie., all samples at once) is more efficient than setting one sample at a time.</p>
<p>-It is an error to request both bulk and per-sample changes to the same field (without calling <a class="el" href="classgamgee_1_1_variant_builder.html#ae53a85c2274e8af69098176451aa4ac5" title="Clear all field values in this builder to prepare it for the next build operation. ">clear()</a> in between). This is because it would be too costly to reconcile the two kinds of changes.</p>
<p>-The bulk-setting functions that take a <a class="el" href="classgamgee_1_1_variant_builder_multi_sample_vector.html" title="Class that allows you to efficiently prepare multi-sample data for setting individual fields in Varia...">VariantBuilderMultiSampleVector</a> (which internally is a pre-padded one-dimensional vector of values) are much more efficient than the functions that take a two-dimensional vector, but the <a class="el" href="classgamgee_1_1_variant_builder_multi_sample_vector.html" title="Class that allows you to efficiently prepare multi-sample data for setting individual fields in Varia...">VariantBuilderMultiSampleVector</a> approach requires a bit more work to use, and also requires that you know the maximum number of values per sample for the field in advance.</p>
<p>For example, with 4 samples and an integer individual field with a varied number of values per sample, you could pass in the following two-dimensional vector:</p>
<p>{ {1, 2}, {3}, {}, {5, 6, 7} }</p>
<p>with each inner vector representing the values for one sample. However, this nested vector is a fairly inefficient data structure with poor data locality/cache performance.</p>
<p>If high performance is desired, you can use a <a class="el" href="classgamgee_1_1_variant_builder_multi_sample_vector.html" title="Class that allows you to efficiently prepare multi-sample data for setting individual fields in Varia...">VariantBuilderMultiSampleVector</a> instead of a two-dimensional vector:</p>
<p>First determine the number of samples and the maximum number of values per sample for the field. Then get a pre-initialized <a class="el" href="classgamgee_1_1_variant_builder_multi_sample_vector.html" title="Class that allows you to efficiently prepare multi-sample data for setting individual fields in Varia...">VariantBuilderMultiSampleVector</a> from the builder:</p>
<p>auto multi_sample_vector = builder.get_integer_multi_sample_vector(num_samples, max_values_per_sample);</p>
<p>This vector will have missing values for all samples, with appropriate padding to the maximum field width.</p>
<p>Then, fill in the values for each non-missing sample by invoking the set_sample_value() and/or set_sample_values() functions on your multi-sample vector (NOTE: set_sample_value() is MUCH more efficient than set_sample_values() since it doesn't require a vector construction/destruction for each call). You don't have to worry about samples with no values, since all samples start out with missing values.</p>
<p>Finally, pass your multi-sample vector into a setter function (favoring the functions that take field indices and use move semantics for high performance):</p>
<p>builder.set_integer_individual_field(field_index, std::move(multi_sample_vector));</p>
<p>The advantage of the <a class="el" href="classgamgee_1_1_variant_builder_multi_sample_vector.html" title="Class that allows you to efficiently prepare multi-sample data for setting individual fields in Varia...">VariantBuilderMultiSampleVector</a> approach is much greater efficiency in terms of data locality and memory allocations.</p>
<p>-The genotype setter functions DO NOT require you to encode your genotype data with one of the <a class="el" href="classgamgee_1_1_genotype.html#a014bc9217f7c78d56ae017da672ceb2a" title="Converts a vector of allele indices representing a genotype into BCF-encoded format suitable for pass...">Genotype::encode_genotype()</a> functions before passing it in &ndash; they will call the appropriate encode function for you. Pass your genotypes by rvalue (ie., use std::move()) if you want to avoid an extra copy during genotype encoding and don't need to re-use your genotype data. See the comments to the <a class="el" href="classgamgee_1_1_genotype.html" title="Encodes a genotype. ">Genotype</a> setter functions for examples of how to construct and pass in genotypes. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="ace610039f04b4360626880dc9df306e1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">gamgee::VariantBuilder::VariantBuilder </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgamgee_1_1_variant_header.html">VariantHeader</a> &amp;&#160;</td>
          <td class="paramname"><em>header</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a new <a class="el" href="classgamgee_1_1_variant_builder.html" title="VariantBuilder: construct Variant records from scratch (and, coming soon, from existing Variant recor...">VariantBuilder</a> given a <a class="el" href="classgamgee_1_1_variant_header.html" title="Utility class to hold a variant header. ">VariantHeader</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">header</td><td><a class="el" href="classgamgee_1_1_variant_header.html" title="Utility class to hold a variant header. ">VariantHeader</a> to use for constructing and validating new <a class="el" href="classgamgee_1_1_variant.html" title="Utility class to manipulate a Variant record. ">Variant</a> records</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>header will become the header for all <a class="el" href="classgamgee_1_1_variant.html" title="Utility class to manipulate a Variant record. ">Variant</a> records created, and so must be appropriate for the final <a class="el" href="classgamgee_1_1_variant.html" title="Utility class to manipulate a Variant record. ">Variant</a> records you intend to create (with all shared/individual fields, samples, and contigs pre-declared)</dd>
<dd>
It's much more efficient to create a single <a class="el" href="classgamgee_1_1_variant_builder.html" title="VariantBuilder: construct Variant records from scratch (and, coming soon, from existing Variant recor...">VariantBuilder</a> and re-use it across records (calling <a class="el" href="classgamgee_1_1_variant_builder.html#ae53a85c2274e8af69098176451aa4ac5" title="Clear all field values in this builder to prepare it for the next build operation. ">clear()</a> as needed) instead of creating a new <a class="el" href="classgamgee_1_1_variant_builder.html" title="VariantBuilder: construct Variant records from scratch (and, coming soon, from existing Variant recor...">VariantBuilder</a> for each record. <a class="el" href="classgamgee_1_1_variant_builder.html" title="VariantBuilder: construct Variant records from scratch (and, coming soon, from existing Variant recor...">VariantBuilder</a> construction involves many memory allocations and is not cheap! </dd></dl>

</div>
</div>
<a class="anchor" id="a7ec544dd5021a2835cad4bf1fd7bab12"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">gamgee::VariantBuilder::VariantBuilder </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgamgee_1_1_variant_builder.html">VariantBuilder</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a25e8a88d0fe8330989aa2fc67866a09b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">gamgee::VariantBuilder::VariantBuilder </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgamgee_1_1_variant_builder.html">VariantBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ac288116a5f57f8d578435da482b3ca7b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">gamgee::VariantBuilder::~VariantBuilder </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a9af2780b3ef03762f437b435cf277a65"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgamgee_1_1_variant.html">Variant</a> gamgee::VariantBuilder::build </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new <a class="el" href="classgamgee_1_1_variant.html" title="Utility class to manipulate a Variant record. ">Variant</a> record using the current state of the builder. </p>
<dl class="section return"><dt>Returns</dt><dd>a new <a class="el" href="classgamgee_1_1_variant.html" title="Utility class to manipulate a Variant record. ">Variant</a> object reflecting the field values currently set in this builder</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Can be called multiple times </dd>
<dd>
It is an error to attempt to build a <a class="el" href="classgamgee_1_1_variant.html" title="Utility class to manipulate a Variant record. ">Variant</a> without having set at least the minimum required fields (chromosome, alignment start, and reference allele) </dd></dl>

</div>
</div>
<a class="anchor" id="ae53a85c2274e8af69098176451aa4ac5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgamgee_1_1_variant_builder.html">VariantBuilder</a> &amp; gamgee::VariantBuilder::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clear all field values in this builder to prepare it for the next build operation. </p>
<dl class="section note"><dt>Note</dt><dd>It's much more efficient to create one <a class="el" href="classgamgee_1_1_variant_builder.html" title="VariantBuilder: construct Variant records from scratch (and, coming soon, from existing Variant recor...">VariantBuilder</a> and <a class="el" href="classgamgee_1_1_variant_builder.html#ae53a85c2274e8af69098176451aa4ac5" title="Clear all field values in this builder to prepare it for the next build operation. ">clear()</a> it between records instead of creating a new <a class="el" href="classgamgee_1_1_variant_builder.html" title="VariantBuilder: construct Variant records from scratch (and, coming soon, from existing Variant recor...">VariantBuilder</a> for each record </dd></dl>

</div>
</div>
<a class="anchor" id="a59728859808bb0e43b285688e58e4e37"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgamgee_1_1_variant_builder_multi_sample_vector.html">VariantBuilderMultiSampleVector</a>&lt; float &gt; gamgee::VariantBuilder::get_float_multi_sample_vector </td>
          <td>(</td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>num_samples</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>max_values_per_sample</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a pre-initialized/padded <a class="el" href="classgamgee_1_1_variant_builder_multi_sample_vector.html" title="Class that allows you to efficiently prepare multi-sample data for setting individual fields in Varia...">VariantBuilderMultiSampleVector</a> for use with the more-efficient float individual field bulk setters. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">num_samples</td><td>number of samples whose values will be stored in the vector </td></tr>
    <tr><td class="paramname">max_values_per_sample</td><td>maximum number of values per sample (field width)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pre-initialized/pre-padded VariantBuilderMultiSampleVector&lt;float&gt; with all samples set to a missing value, ready for sample values to be set for non-missing samples</dd></dl>
<dl class="section note"><dt>Note</dt><dd>For usage, see comments to the float individual field setters that take a <a class="el" href="classgamgee_1_1_variant_builder_multi_sample_vector.html" title="Class that allows you to efficiently prepare multi-sample data for setting individual fields in Varia...">VariantBuilderMultiSampleVector</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a84a13b9951eeaeb4e28bfb42c94d785b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgamgee_1_1_variant_builder_multi_sample_vector.html">VariantBuilderMultiSampleVector</a>&lt; int32_t &gt; gamgee::VariantBuilder::get_genotype_multi_sample_vector </td>
          <td>(</td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>num_samples</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>max_values_per_sample</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a pre-initialized/padded <a class="el" href="classgamgee_1_1_variant_builder_multi_sample_vector.html" title="Class that allows you to efficiently prepare multi-sample data for setting individual fields in Varia...">VariantBuilderMultiSampleVector</a> for use with the more-efficient GT field bulk setters. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">num_samples</td><td>number of samples whose genotypes will be stored in the vector </td></tr>
    <tr><td class="paramname">max_values_per_sample</td><td>maximum ploidy (field width)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pre-initialized/pre-padded VariantBuilderMultiSampleVector&lt;int32_t&gt; with all samples set to a missing value, ready for genotypes to be set for non-missing samples</dd></dl>
<dl class="section note"><dt>Note</dt><dd>For usage, see comments to the GT field setters that take a <a class="el" href="classgamgee_1_1_variant_builder_multi_sample_vector.html" title="Class that allows you to efficiently prepare multi-sample data for setting individual fields in Varia...">VariantBuilderMultiSampleVector</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a1be11bfcf550d80d7015d7b2aaed0705"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgamgee_1_1_variant_builder_multi_sample_vector.html">VariantBuilderMultiSampleVector</a>&lt; int32_t &gt; gamgee::VariantBuilder::get_integer_multi_sample_vector </td>
          <td>(</td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>num_samples</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>max_values_per_sample</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a pre-initialized/padded <a class="el" href="classgamgee_1_1_variant_builder_multi_sample_vector.html" title="Class that allows you to efficiently prepare multi-sample data for setting individual fields in Varia...">VariantBuilderMultiSampleVector</a> for use with the more-efficient integer individual field bulk setters. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">num_samples</td><td>number of samples whose values will be stored in the vector </td></tr>
    <tr><td class="paramname">max_values_per_sample</td><td>maximum number of values per sample (field width)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pre-initialized/pre-padded VariantBuilderMultiSampleVector&lt;int32_t&gt; with all samples set to a missing value, ready for sample values to be set for non-missing samples</dd></dl>
<dl class="section note"><dt>Note</dt><dd>For usage, see comments to the integer individual field setters that take a <a class="el" href="classgamgee_1_1_variant_builder_multi_sample_vector.html" title="Class that allows you to efficiently prepare multi-sample data for setting individual fields in Varia...">VariantBuilderMultiSampleVector</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ad839d1da158385dc3fbd9a558d55b14b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgamgee_1_1_variant_header.html">VariantHeader</a> gamgee::VariantBuilder::header </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the <a class="el" href="classgamgee_1_1_variant.html" title="Utility class to manipulate a Variant record. ">Variant</a> header for this builder. </p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classgamgee_1_1_variant.html" title="Utility class to manipulate a Variant record. ">Variant</a> header this builder was constructed with (and which becomes the header for any <a class="el" href="classgamgee_1_1_variant.html" title="Utility class to manipulate a Variant record. ">Variant</a> records built) </dd></dl>

</div>
</div>
<a class="anchor" id="a224958078f9072126206c1e11c7d923b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgamgee_1_1_variant_builder.html">VariantBuilder</a>&amp; gamgee::VariantBuilder::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgamgee_1_1_variant_builder.html">VariantBuilder</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="afc86504ec9138ed9505227f525245240"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgamgee_1_1_variant_builder.html">VariantBuilder</a>&amp; gamgee::VariantBuilder::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgamgee_1_1_variant_builder.html">VariantBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="abbfc654cff9b49d40c7b1b67df97cfad"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgamgee_1_1_variant_builder.html">VariantBuilder</a> &amp; gamgee::VariantBuilder::remove_alignment_stop </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clear the alignment stop value (if set) </p>

</div>
</div>
<a class="anchor" id="a3e1adb976cb519752295ba81a4278d35"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgamgee_1_1_variant_builder.html">VariantBuilder</a> &amp; gamgee::VariantBuilder::remove_alt_alleles </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clear alt alleles (if set) </p>

</div>
</div>
<a class="anchor" id="a7d4a69132f5d179dcf2def5ecc51f458"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgamgee_1_1_variant_builder.html">VariantBuilder</a> &amp; gamgee::VariantBuilder::remove_filters </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clear filters (if set) </p>

</div>
</div>
<a class="anchor" id="aa2bbb85da5628323df90e8822abbccf6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgamgee_1_1_variant_builder.html">VariantBuilder</a> &amp; gamgee::VariantBuilder::remove_id </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clear the ID field (if set) </p>

</div>
</div>
<a class="anchor" id="a0e868c51ef47d83910811eb5d9906549"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgamgee_1_1_variant_builder.html">VariantBuilder</a> &amp; gamgee::VariantBuilder::remove_individual_field </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>tag</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove an individual field by field name. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tag</td><td>name of the individual field to remove</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Less efficient than removing using the field index </dd></dl>

</div>
</div>
<a class="anchor" id="a72303ecbab803da346641df7462f7ee0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgamgee_1_1_variant_builder.html">VariantBuilder</a> &amp; gamgee::VariantBuilder::remove_individual_field </td>
          <td>(</td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>field_index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove an individual field by field index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field_index</td><td>index of the individual field to remove (from a header lookup) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ace7220abe7a8471b366f59be247c919b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgamgee_1_1_variant_builder.html">VariantBuilder</a> &amp; gamgee::VariantBuilder::remove_individual_fields </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>tags</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove multiple individual fields by field name. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tags</td><td>names of the individual fields to remove</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Less efficient than removing using the field indices </dd></dl>

</div>
</div>
<a class="anchor" id="adc19a0d513d8ef0a83931fb02214bc0b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgamgee_1_1_variant_builder.html">VariantBuilder</a> &amp; gamgee::VariantBuilder::remove_individual_fields </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; uint32_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>field_indices</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove multiple individual fields by field index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field_indices</td><td>indices of the individual fields to remove (from header lookups) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a531375e15d4108ee508a4e2d6ff35fc4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgamgee_1_1_variant_builder.html">VariantBuilder</a> &amp; gamgee::VariantBuilder::remove_qual </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clear the qual field (if set) </p>

</div>
</div>
<a class="anchor" id="af8b0b7e5832fe47a51d3a90dec1a639b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgamgee_1_1_variant_builder.html">VariantBuilder</a> &amp; gamgee::VariantBuilder::remove_shared_field </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>tag</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove a shared field by field name. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tag</td><td>name of the shared field to remove</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Less efficient than removing using the field index </dd></dl>

</div>
</div>
<a class="anchor" id="a53c4f9b8a2fc516d920ef0a4b6d5552a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgamgee_1_1_variant_builder.html">VariantBuilder</a> &amp; gamgee::VariantBuilder::remove_shared_field </td>
          <td>(</td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>field_index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove a shared field by field index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field_index</td><td>index of the shared field to remove (from a header lookup) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa3999d10bdd6fba52c401edaf746bac2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgamgee_1_1_variant_builder.html">VariantBuilder</a> &amp; gamgee::VariantBuilder::remove_shared_fields </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>tags</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove multiple shared fields by field name. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tags</td><td>names of the shared fields to remove</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Less efficient than removing using the field indices </dd></dl>

</div>
</div>
<a class="anchor" id="ae2c2838f81febe53c64abb00138cd786"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgamgee_1_1_variant_builder.html">VariantBuilder</a> &amp; gamgee::VariantBuilder::remove_shared_fields </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; uint32_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>field_indices</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove multiple shared fields by field index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field_indices</td><td>indices of the shared fields to remove (from header lookups) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad76787fa7e4077b87d3c2ad414cd6371"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgamgee_1_1_variant_builder.html">VariantBuilder</a> &amp; gamgee::VariantBuilder::set_alignment_start </td>
          <td>(</td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>alignment_start</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the alignment start position. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">alignment_start</td><td>1-based alignment start position (as you would see in a VCF file)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>the internal encoding is 0-based to mimic that of the BCF files </dd></dl>

</div>
</div>
<a class="anchor" id="af80e48e3d14ff5a9613660b54277bf4d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgamgee_1_1_variant_builder.html">VariantBuilder</a> &amp; gamgee::VariantBuilder::set_alignment_stop </td>
          <td>(</td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>alignment_stop</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the alignment stop position. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">alignment_stop</td><td>1-based alignment stop position (as you would see in a VCF INFO END tag)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>the internal encoding is 0-based to mimic that of the BCF files </dd></dl>

</div>
</div>
<a class="anchor" id="a8b1a027a239bfbdb9a3a8bec4203f28c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgamgee_1_1_variant_builder.html">VariantBuilder</a> &amp; gamgee::VariantBuilder::set_alt_allele </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>alt_allele</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the alt allele. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">alt_allele</td><td>alt allele as a string</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Alt allele passed in replaces any previous value(s) for the alt field </dd>
<dd>
It's more efficient to use this function when there's only a single alt allele instead of the vector-based setter </dd></dl>

</div>
</div>
<a class="anchor" id="ab90c4dd560168c88114280fc86543bbe"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgamgee_1_1_variant_builder.html">VariantBuilder</a> &amp; gamgee::VariantBuilder::set_alt_alleles </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>alt_alleles</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the alt alleles. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">alt_alleles</td><td>one string per alt allele</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Alt alleles passed in replace any previous value(s) for the alt field </dd>
<dd>
It's more efficient to use the setter that takes a single string when there's only one alt allele </dd></dl>

</div>
</div>
<a class="anchor" id="a3ebd884661b9d03fbf9305d4329b0100"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgamgee_1_1_variant_builder.html">VariantBuilder</a> &amp; gamgee::VariantBuilder::set_boolean_shared_field </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>tag</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set a boolean (flag) shared field by field name. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tag</td><td>name of the shared field to set</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Field is set to true/present. To set a boolean field to false call one of the <a class="el" href="classgamgee_1_1_variant_builder.html#af8b0b7e5832fe47a51d3a90dec1a639b" title="Remove a shared field by field name. ">remove_shared_field()</a> functions.</dd>
<dd>
Less efficient than setting using the field index </dd></dl>

</div>
</div>
<a class="anchor" id="a0a7061bbc187d2720e09111deda13080"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgamgee_1_1_variant_builder.html">VariantBuilder</a> &amp; gamgee::VariantBuilder::set_boolean_shared_field </td>
          <td>(</td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set a boolean (flag) shared field by field index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>index of the shared field to set (from a header lookup)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Field is set to true/present. To set a boolean field to false call one of the <a class="el" href="classgamgee_1_1_variant_builder.html#af8b0b7e5832fe47a51d3a90dec1a639b" title="Remove a shared field by field name. ">remove_shared_field()</a> functions. </dd></dl>

</div>
</div>
<a class="anchor" id="a4494b555f8f0a09793c5d9da22ffc4a8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgamgee_1_1_variant_builder.html">VariantBuilder</a> &amp; gamgee::VariantBuilder::set_chromosome </td>
          <td>(</td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>chromosome</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the chromosome by index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">chromosome</td><td>chromosome index (from a header lookup) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6062d271de74f46d6767b5847f6f359d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgamgee_1_1_variant_builder.html">VariantBuilder</a> &amp; gamgee::VariantBuilder::set_chromosome </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>chromosome</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the chromosome by name. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">chromosome</td><td>chromosome name </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7cb2d600ba1e3249b1533fe7be9ae8f1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgamgee_1_1_variant_builder.html">VariantBuilder</a> &amp; gamgee::VariantBuilder::set_enable_validation </td>
          <td>(</td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>enable_validation</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disable or enable all validation checks in this builder. </p>
<p>Passing in false disables validation, passing in true enables it. Validation is on by default in new builders.</p>
<dl class="section warning"><dt>Warning</dt><dd>Disabling validation will improve performance at the cost of safety. Only do so if you're extremely confident that your program will not take any invalid/incorrect actions, and that the data you pass to the builder will always be valid. </dd></dl>

</div>
</div>
<a class="anchor" id="af7d74effdfa3d0a05e5b430fb46b5339"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgamgee_1_1_variant_builder.html">VariantBuilder</a> &amp; gamgee::VariantBuilder::set_filters </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>filters</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the filters using filter names. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filters</td><td>vector of filter names</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>It's more efficient to set using filter indices </dd></dl>

</div>
</div>
<a class="anchor" id="a20952eb544025ff80c314c251962f3ee"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgamgee_1_1_variant_builder.html">VariantBuilder</a> &amp; gamgee::VariantBuilder::set_filters </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; int32_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>filters</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the filters using filter indices. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filters</td><td>vector of filter indices (from header lookups) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7a23a09aa081ebf2171337077feb8e63"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgamgee_1_1_variant_builder.html">VariantBuilder</a> &amp; gamgee::VariantBuilder::set_float_individual_field </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgamgee_1_1_variant_builder_multi_sample_vector.html">VariantBuilderMultiSampleVector</a>&lt; float &gt; &amp;&#160;</td>
          <td class="paramname"><em>values_for_all_samples</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set a float individual field for all samples at once by name using an efficient flattened (one-dimensional) vector, COPYING the provided values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tag</td><td>name of the individual field to set </td></tr>
    <tr><td class="paramname">values_for_all_samples</td><td>field values for all samples as a <a class="el" href="classgamgee_1_1_variant_builder_multi_sample_vector.html" title="Class that allows you to efficiently prepare multi-sample data for setting individual fields in Varia...">VariantBuilderMultiSampleVector</a> (see note below)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>To create a multi-sample flattened vector for use with this function, first determine the number of samples and the maximum number of values per sample for this field, then get a pre-initialized vector from the builder:</dd></dl>
<p>auto multi_sample_vector = builder.get_float_multi_sample_vector(num_samples, max_values_per_sample);</p>
<p>This vector will have missing values for all samples, with appropriate padding to the maximum field width.</p>
<p>Then, fill in the values for each non-missing sample by invoking the set_sample_value() and/or set_sample_values() functions on your multi-sample vector (set_sample_value() is more efficient than set_sample_values() since it doesn't require a vector construction/destruction for each call). You don't have to worry about samples with no values, since all samples start out with missing values.</p>
<p>Finally, pass your multi-sample vector into this function:</p>
<p>builder.set_float_individual_field(field_name, multi_sample_vector);</p>
<p>If this process is too inconvenient, or you can't know the maximum number of values per sample in advance, use a less-efficient function that takes a nested vector.</p>
<dl class="section note"><dt>Note</dt><dd>Less efficient than moving the values into the builder </dd>
<dd>
Less efficient than setting using the field index </dd></dl>

</div>
</div>
<a class="anchor" id="a5ab5688fb53a51951674bd51fd09bfde"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgamgee_1_1_variant_builder.html">VariantBuilder</a> &amp; gamgee::VariantBuilder::set_float_individual_field </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgamgee_1_1_variant_builder_multi_sample_vector.html">VariantBuilderMultiSampleVector</a>&lt; float &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>values_for_all_samples</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set a float individual field for all samples at once by name using an efficient flattened (one-dimensional) vector, MOVING the provided values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tag</td><td>name of the individual field to set </td></tr>
    <tr><td class="paramname">values_for_all_samples</td><td>field values for all samples as a <a class="el" href="classgamgee_1_1_variant_builder_multi_sample_vector.html" title="Class that allows you to efficiently prepare multi-sample data for setting individual fields in Varia...">VariantBuilderMultiSampleVector</a> (see note below)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>To create a multi-sample flattened vector for use with this function, first determine the number of samples and the maximum number of values per sample for this field, then get a pre-initialized vector from the builder:</dd></dl>
<p>auto multi_sample_vector = builder.get_float_multi_sample_vector(num_samples, max_values_per_sample);</p>
<p>This vector will have missing values for all samples, with appropriate padding to the maximum field width.</p>
<p>Then, fill in the values for each non-missing sample by invoking the set_sample_value() and/or set_sample_values() functions on your multi-sample vector (set_sample_value() is more efficient than set_sample_values() since it doesn't require a vector construction/destruction for each call). You don't have to worry about samples with no values, since all samples start out with missing values.</p>
<p>Finally, MOVE your multi-sample vector into this function:</p>
<p>builder.set_float_individual_field(field_name, std::move(multi_sample_vector));</p>
<p>If this process is too inconvenient, or you can't know the maximum number of values per sample in advance, use a less-efficient function that takes a nested vector.</p>
<dl class="section note"><dt>Note</dt><dd>Less efficient than setting using the field index </dd></dl>

</div>
</div>
<a class="anchor" id="ad3495cfd6e141aa92919277bee5a3889"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgamgee_1_1_variant_builder.html">VariantBuilder</a> &amp; gamgee::VariantBuilder::set_float_individual_field </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; float &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>values_for_all_samples</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set a float individual field for all samples at once by name using a nested vector, copying the provided values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tag</td><td>name of the individual field to set </td></tr>
    <tr><td class="paramname">values_for_all_samples</td><td>field values for all samples in order of sample index, with one inner vector per sample (no special padding necessary)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>With a nested vector, each inner vector represents the values for the sample with the corresponding index. There is no need to manually pad with missing/vector end values. For example:</dd></dl>
<p>{ {1.5, 2.5}, {3.5}, {}, {5.5, 6.5, 7.5} }</p>
<dl class="section note"><dt>Note</dt><dd>Less efficient than using a flattened vector </dd>
<dd>
Less efficient than moving the values into the builder </dd>
<dd>
Less efficient than setting using the field index </dd></dl>

</div>
</div>
<a class="anchor" id="a3e14a944b1b174bbdac63890b0f820ce"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgamgee_1_1_variant_builder.html">VariantBuilder</a> &amp; gamgee::VariantBuilder::set_float_individual_field </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; float &gt;&gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>values_for_all_samples</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set a float individual field for all samples at once by name using a nested vector, moving the provided values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tag</td><td>name of the individual field to set </td></tr>
    <tr><td class="paramname">values_for_all_samples</td><td>field values for all samples in order of sample index, with one inner vector per sample (no special padding necessary)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>With a nested vector, each inner vector represents the values for the sample with the corresponding index. There is no need to manually pad with missing/vector end values. For example:</dd></dl>
<p>{ {1.5, 2.5}, {3.5}, {}, {5.5, 6.5, 7.5} }</p>
<dl class="section note"><dt>Note</dt><dd>Less efficient than using a flattened vector </dd>
<dd>
Less efficient than setting using the field index </dd></dl>

</div>
</div>
<a class="anchor" id="a754d950816e0bcb7a018cfbf4f6e7f9c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgamgee_1_1_variant_builder.html">VariantBuilder</a> &amp; gamgee::VariantBuilder::set_float_individual_field </td>
          <td>(</td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>field_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgamgee_1_1_variant_builder_multi_sample_vector.html">VariantBuilderMultiSampleVector</a>&lt; float &gt; &amp;&#160;</td>
          <td class="paramname"><em>values_for_all_samples</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set a float individual field for all samples at once by index using an efficient flattened (one-dimensional) vector, COPYING the provided values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field_index</td><td>index of the individual field to set (from a header lookup) </td></tr>
    <tr><td class="paramname">values_for_all_samples</td><td>field values for all samples as a <a class="el" href="classgamgee_1_1_variant_builder_multi_sample_vector.html" title="Class that allows you to efficiently prepare multi-sample data for setting individual fields in Varia...">VariantBuilderMultiSampleVector</a> (see note below)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>To create a multi-sample flattened vector for use with this function, first determine the number of samples and the maximum number of values per sample for this field, then get a pre-initialized vector from the builder:</dd></dl>
<p>auto multi_sample_vector = builder.get_float_multi_sample_vector(num_samples, max_values_per_sample);</p>
<p>This vector will have missing values for all samples, with appropriate padding to the maximum field width.</p>
<p>Then, fill in the values for each non-missing sample by invoking the set_sample_value() and/or set_sample_values() functions on your multi-sample vector (set_sample_value() is more efficient than set_sample_values() since it doesn't require a vector construction/destruction for each call). You don't have to worry about samples with no values, since all samples start out with missing values.</p>
<p>Finally, pass your multi-sample vector into this function:</p>
<p>builder.set_float_individual_field(field_index, multi_sample_vector);</p>
<p>If this process is too inconvenient, or you can't know the maximum number of values per sample in advance, use a less-efficient function that takes a nested vector.</p>
<dl class="section note"><dt>Note</dt><dd>Less efficient than moving the values into the builder </dd></dl>

</div>
</div>
<a class="anchor" id="a91e44b54c59fbc7ddf8fb2155c5b53f3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgamgee_1_1_variant_builder.html">VariantBuilder</a> &amp; gamgee::VariantBuilder::set_float_individual_field </td>
          <td>(</td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>field_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgamgee_1_1_variant_builder_multi_sample_vector.html">VariantBuilderMultiSampleVector</a>&lt; float &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>values_for_all_samples</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set a float individual field for all samples at once by index using an efficient flattened (one-dimensional) vector, MOVING the provided values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field_index</td><td>index of the individual field to set (from a header lookup) </td></tr>
    <tr><td class="paramname">values_for_all_samples</td><td>field values for all samples as a <a class="el" href="classgamgee_1_1_variant_builder_multi_sample_vector.html" title="Class that allows you to efficiently prepare multi-sample data for setting individual fields in Varia...">VariantBuilderMultiSampleVector</a> (see note below)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>To create a multi-sample flattened vector for use with this function, first determine the number of samples and the maximum number of values per sample for this field, then get a pre-initialized vector from the builder:</dd></dl>
<p>auto multi_sample_vector = builder.get_float_multi_sample_vector(num_samples, max_values_per_sample);</p>
<p>This vector will have missing values for all samples, with appropriate padding to the maximum field width.</p>
<p>Then, fill in the values for each non-missing sample by invoking the set_sample_value() and/or set_sample_values() functions on your multi-sample vector (set_sample_value() is more efficient than set_sample_values() since it doesn't require a vector construction/destruction for each call). You don't have to worry about samples with no values, since all samples start out with missing values.</p>
<p>Finally, MOVE your multi-sample vector into this function:</p>
<p>builder.set_float_individual_field(field_index, std::move(multi_sample_vector));</p>
<p>If this process is too inconvenient, or you can't know the maximum number of values per sample in advance, use a less-efficient function that takes a nested vector. </p>

</div>
</div>
<a class="anchor" id="a7a2e781f73831057f13a3e3a6433cf82"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgamgee_1_1_variant_builder.html">VariantBuilder</a> &amp; gamgee::VariantBuilder::set_float_individual_field </td>
          <td>(</td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>field_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; float &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>values_for_all_samples</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set a float individual field for all samples at once by index using a nested vector, copying the provided values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field_index</td><td>index of the individual field to set (from a header lookup) </td></tr>
    <tr><td class="paramname">values_for_all_samples</td><td>field values for all samples in order of sample index, with one inner vector per sample (no special padding necessary)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>With a nested vector, each inner vector represents the values for the sample with the corresponding index. There is no need to manually pad with missing/vector end values. For example:</dd></dl>
<p>{ {1.5, 2.5}, {3.5}, {}, {5.5, 6.5, 7.5} }</p>
<dl class="section note"><dt>Note</dt><dd>Less efficient than using a flattened vector </dd>
<dd>
Less efficient than moving the values into the builder </dd></dl>

</div>
</div>
<a class="anchor" id="adb7e4ac0f78573ab68d16dd00bffb144"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgamgee_1_1_variant_builder.html">VariantBuilder</a> &amp; gamgee::VariantBuilder::set_float_individual_field </td>
          <td>(</td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>field_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; float &gt;&gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>values_for_all_samples</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set a float individual field for all samples at once by index using a nested vector, moving the provided values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field_index</td><td>index of the individual field to set (from a header lookup) </td></tr>
    <tr><td class="paramname">values_for_all_samples</td><td>field values for all samples in order of sample index, with one inner vector per sample (no special padding necessary)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>With a nested vector, each inner vector represents the values for the sample with the corresponding index. There is no need to manually pad with missing/vector end values. For example:</dd></dl>
<p>{ {1.5, 2.5}, {3.5}, {}, {5.5, 6.5, 7.5} }</p>
<dl class="section note"><dt>Note</dt><dd>Less efficient than using a flattened vector </dd></dl>

</div>
</div>
<a class="anchor" id="aa0ce5bf2a9fab384beb546f8e4fdb532"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgamgee_1_1_variant_builder.html">VariantBuilder</a> &amp; gamgee::VariantBuilder::set_float_individual_field </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>sample</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set a single-valued float individual field for a single sample by field and sample name. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tag</td><td>name of the individual field to set </td></tr>
    <tr><td class="paramname">sample</td><td>name of the sample whose value to set </td></tr>
    <tr><td class="paramname">value</td><td>field value for the specified sample</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>It's more efficient to use this setter instead of a vector-based setter when a sample has just a single value for a field </dd>
<dd>
Less efficient than setting using the field/sample indices </dd></dl>

</div>
</div>
<a class="anchor" id="afbfd4576c6477c3088d1b53e603d5d26"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgamgee_1_1_variant_builder.html">VariantBuilder</a> &amp; gamgee::VariantBuilder::set_float_individual_field </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>sample</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; float &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set a multi-valued float individual field for a single sample by field and sample name. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tag</td><td>name of the individual field to set </td></tr>
    <tr><td class="paramname">sample</td><td>name of the sample whose value to set </td></tr>
    <tr><td class="paramname">values</td><td>field values for the specified sample</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Less efficient than setting using the field/sample indices </dd></dl>

</div>
</div>
<a class="anchor" id="a1557ea3f4a29ce96495c6cd8795abb52"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgamgee_1_1_variant_builder.html">VariantBuilder</a> &amp; gamgee::VariantBuilder::set_float_individual_field </td>
          <td>(</td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>field_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>sample_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set a single-valued float individual field for a single sample by field and sample index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field_index</td><td>index of the individual field to set (from a header lookup) </td></tr>
    <tr><td class="paramname">sample_index</td><td>index of the sample whose value to set (from a header lookup) </td></tr>
    <tr><td class="paramname">value</td><td>field value for the specified sample</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>It's more efficient to use this setter instead of a vector-based setter when a sample has just a single value for a field </dd></dl>

</div>
</div>
<a class="anchor" id="a33fb12a456b9adfeb5fabe2934bae940"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgamgee_1_1_variant_builder.html">VariantBuilder</a> &amp; gamgee::VariantBuilder::set_float_individual_field </td>
          <td>(</td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>field_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>sample_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; float &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set a multi-valued float individual field for a single sample by field and sample index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field_index</td><td>index of the individual field to set (from a header lookup) </td></tr>
    <tr><td class="paramname">sample_index</td><td>index of the sample whose value to set (from a header lookup) </td></tr>
    <tr><td class="paramname">values</td><td>field values for the specified sample </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a07abd11965be32f2da970bb3d44e424c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgamgee_1_1_variant_builder.html">VariantBuilder</a> &amp; gamgee::VariantBuilder::set_float_shared_field </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set a single-valued float shared field by field name. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tag</td><td>name of the shared field to set </td></tr>
    <tr><td class="paramname">value</td><td>new value for the field</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>It's more efficient to use this setter instead of a vector-based setter when a field has just a single value</dd>
<dd>
Less efficient than setting using the field index </dd></dl>

</div>
</div>
<a class="anchor" id="afc6b8f4c1d727c116d9bf5d70cbbfda2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgamgee_1_1_variant_builder.html">VariantBuilder</a> &amp; gamgee::VariantBuilder::set_float_shared_field </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; float &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set a multi-valued float shared field by field name. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tag</td><td>name of the shared field to set </td></tr>
    <tr><td class="paramname">values</td><td>new values for the field</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Less efficient than setting using the field index </dd></dl>

</div>
</div>
<a class="anchor" id="af0e9e1be6fc88b1a2186326dc666a13c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgamgee_1_1_variant_builder.html">VariantBuilder</a> &amp; gamgee::VariantBuilder::set_float_shared_field </td>
          <td>(</td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set a single-valued float shared field by field index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>index of the shared field to set (from a header lookup) </td></tr>
    <tr><td class="paramname">value</td><td>new value for the field</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>It's more efficient to use this setter instead of a vector-based setter when a field has just a single value </dd></dl>

</div>
</div>
<a class="anchor" id="a35c6bfe5ed8f5f9313a14f3c417d0da9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgamgee_1_1_variant_builder.html">VariantBuilder</a> &amp; gamgee::VariantBuilder::set_float_shared_field </td>
          <td>(</td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; float &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set a multi-valued float shared field by field index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>index of the shared field to set (from a header lookup) </td></tr>
    <tr><td class="paramname">values</td><td>new values for the field </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab8fe52db4cc7f67fabd8a91610de9eaa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgamgee_1_1_variant_builder.html">VariantBuilder</a> &amp; gamgee::VariantBuilder::set_genotype </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>sample</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; int32_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>genotype</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the genotypes (GT) field for a single sample by sample name, copying the genotype before encoding. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sample</td><td>name of the sample whose genotype to set </td></tr>
    <tr><td class="paramname">genotype</td><td>genotype for the specified sample (see notes below)</td></tr>
  </table>
  </dd>
</dl>
<p>Examples: For genotype 0/1, create vector {0, 1} For genotype 1/., create vector {1, -1} For genotype ./., create vector {-1, -1}</p>
<dl class="section note"><dt>Note</dt><dd>Does not support genotypes with phased alleles </dd>
<dd>
Less efficient than moving the genotype into the builder </dd>
<dd>
Less efficient than setting using the sample index </dd></dl>

</div>
</div>
<a class="anchor" id="af64883ed26f97f9471b591b8bc400b2b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgamgee_1_1_variant_builder.html">VariantBuilder</a> &amp; gamgee::VariantBuilder::set_genotype </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>sample</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int32_t &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>genotype</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the genotypes (GT) field for a single sample by sample name, moving the genotype into the builder and encoding in-place. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sample</td><td>name of the sample whose genotype to set </td></tr>
    <tr><td class="paramname">genotype</td><td>genotype for the specified sample (see notes below)</td></tr>
  </table>
  </dd>
</dl>
<p>Examples: For genotype 0/1, create vector {0, 1} For genotype 1/., create vector {1, -1} For genotype ./., create vector {-1, -1}</p>
<dl class="section note"><dt>Note</dt><dd>Does not support genotypes with phased alleles </dd>
<dd>
Less efficient than setting using the sample index </dd></dl>

</div>
</div>
<a class="anchor" id="ac7998a9347ae72b97a607c6773a23f08"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgamgee_1_1_variant_builder.html">VariantBuilder</a> &amp; gamgee::VariantBuilder::set_genotype </td>
          <td>(</td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>sample_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; int32_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>genotype</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the genotypes (GT) field for a single sample by sample index, copying the genotype before encoding. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sample_index</td><td>index of the sample whose genotype to set (from a header lookup) </td></tr>
    <tr><td class="paramname">genotype</td><td>genotype for the specified sample (see notes below)</td></tr>
  </table>
  </dd>
</dl>
<p>Examples: For genotype 0/1, create vector {0, 1} For genotype 1/., create vector {1, -1} For genotype ./., create vector {-1, -1}</p>
<dl class="section note"><dt>Note</dt><dd>Does not support genotypes with phased alleles </dd>
<dd>
Less efficient than moving the genotype into the builder </dd></dl>

</div>
</div>
<a class="anchor" id="a9ff527e8ac6e0c5c19e2c3c372e67281"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgamgee_1_1_variant_builder.html">VariantBuilder</a> &amp; gamgee::VariantBuilder::set_genotype </td>
          <td>(</td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>sample_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int32_t &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>genotype</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the genotypes (GT) field for a single sample by sample index, moving the genotype into the builder and encoding in-place. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sample_index</td><td>index of the sample whose genotype to set (from a header lookup) </td></tr>
    <tr><td class="paramname">genotype</td><td>genotype for the specified sample (see notes below)</td></tr>
  </table>
  </dd>
</dl>
<p>Examples: For genotype 0/1, create vector {0, 1} For genotype 1/., create vector {1, -1} For genotype ./., create vector {-1, -1}</p>
<dl class="section note"><dt>Note</dt><dd>Does not support genotypes with phased alleles </dd></dl>

</div>
</div>
<a class="anchor" id="a0d1a1436ac871c3ace750329e5ba74c8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgamgee_1_1_variant_builder.html">VariantBuilder</a> &amp; gamgee::VariantBuilder::set_genotypes </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgamgee_1_1_variant_builder_multi_sample_vector.html">VariantBuilderMultiSampleVector</a>&lt; int32_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>genotypes_for_all_samples</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the genotypes (GT) field for all samples at once using an efficient flattened (one-dimensional) vector, COPYING the provided values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">genotypes_for_all_samples</td><td>genotypes for all samples as a <a class="el" href="classgamgee_1_1_variant_builder_multi_sample_vector.html" title="Class that allows you to efficiently prepare multi-sample data for setting individual fields in Varia...">VariantBuilderMultiSampleVector</a> (see note below)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>To create a multi-sample flattened vector for use with this function, first determine the number of samples and the maximum ploidy across all samples, then get a pre-initialized vector from the builder:</dd></dl>
<p>auto multi_sample_vector = builder.get_genotype_multi_sample_vector(num_samples, max_ploidy);</p>
<p>This vector will have missing values for all samples, with appropriate padding to the maximum ploidy.</p>
<p>Then, fill in the values for each non-missing sample by invoking the set_sample_value() and/or set_sample_values() functions on your multi-sample vector (set_sample_value() is more efficient than set_sample_values() since it doesn't require a vector construction/destruction for each call). You don't have to worry about samples with no values, since all samples start out with missing values, however you should represent each no-call allele with -1.</p>
<p>For example, to set sample 0's genotype to 0/1, you could call multi_sample_vector.set_sample_values(0, {0, 1}), or to set it to 1/., you could call multi_sample_vector.set_sample_values(0, {1, -1}). As noted above, setting one allele at a time via set_sample_value() will be more efficient than set_sample_values() since it doesn't require a vector allocation.</p>
<p>Finally, pass your multi-sample vector into this function:</p>
<p>builder.set_genotypes(multi_sample_vector);</p>
<p>If this process is too inconvenient, or you can't know the maximum ploidy in advance, use a less-efficient function that takes a nested vector.</p>
<dl class="section note"><dt>Note</dt><dd>Does not support genotypes with phased alleles </dd>
<dd>
Less efficient than moving the values into the builder </dd></dl>

</div>
</div>
<a class="anchor" id="ada19d70b1b04effa3dae32c1ee9a01a2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgamgee_1_1_variant_builder.html">VariantBuilder</a> &amp; gamgee::VariantBuilder::set_genotypes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgamgee_1_1_variant_builder_multi_sample_vector.html">VariantBuilderMultiSampleVector</a>&lt; int32_t &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>genotypes_for_all_samples</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the genotypes (GT) field for all samples at once using an efficient flattened (one-dimensional) vector, MOVING the provided values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">genotypes_for_all_samples</td><td>genotypes for all samples as a <a class="el" href="classgamgee_1_1_variant_builder_multi_sample_vector.html" title="Class that allows you to efficiently prepare multi-sample data for setting individual fields in Varia...">VariantBuilderMultiSampleVector</a> (see note below)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>To create a multi-sample flattened vector for use with this function, first determine the number of samples and the maximum ploidy across all samples, then get a pre-initialized vector from the builder:</dd></dl>
<p>auto multi_sample_vector = builder.get_genotype_multi_sample_vector(num_samples, max_ploidy);</p>
<p>This vector will have missing values for all samples, with appropriate padding to the maximum ploidy.</p>
<p>Then, fill in the values for each non-missing sample by invoking the set_sample_value() and/or set_sample_values() functions on your multi-sample vector (set_sample_value() is more efficient than set_sample_values() since it doesn't require a vector construction/destruction for each call). You don't have to worry about samples with no values, since all samples start out with missing values, however you should represent each no-call allele with -1.</p>
<p>For example, to set sample 0's genotype to 0/1, you could call multi_sample_vector.set_sample_values(0, {0, 1}), or to set it to 1/., you could call multi_sample_vector.set_sample_values(0, {1, -1}). As noted above, setting one allele at a time via set_sample_value() will be more efficient than set_sample_values() since it doesn't require a vector allocation.</p>
<p>Finally, MOVE your multi-sample vector into this function:</p>
<p>builder.set_genotypes(std::move(multi_sample_vector));</p>
<p>If this process is too inconvenient, or you can't know the maximum ploidy in advance, use a less-efficient function that takes a nested vector.</p>
<dl class="section note"><dt>Note</dt><dd>Does not support genotypes with phased alleles </dd></dl>

</div>
</div>
<a class="anchor" id="afb2c97a4caccae8487520df149a7ef52"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgamgee_1_1_variant_builder.html">VariantBuilder</a> &amp; gamgee::VariantBuilder::set_genotypes </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; int32_t &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>genotypes_for_all_samples</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the genotypes (GT) field for all samples at once by nested vector, COPYING the provided values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">genotypes_for_all_samples</td><td>genotypes for all samples in order of sample index, with one inner vector per sample (no padding necessary)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>With a nested vector, each inner vector represents the genotypes for the sample with the corresponding index. There is no need to manually pad to the maximum ploidy, but you do need to add a missing value (-1) for each missing/no-call allele.</dd></dl>
<p>For example, if you had Sample1=0/1 Sample2=./. Sample3=. Sample4=0/1/2 you would need to create the following nested vector:</p>
<p>{ {0, 1}, {-1, -1}, {}, {0, 1, 2} }</p>
<dl class="section note"><dt>Note</dt><dd>Does not support genotypes with phased alleles </dd>
<dd>
Less efficient than using a flattened vector </dd>
<dd>
Less efficient than moving the values into the builder </dd></dl>

</div>
</div>
<a class="anchor" id="afa4697cf3394eafe427fed6d17a7a174"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgamgee_1_1_variant_builder.html">VariantBuilder</a> &amp; gamgee::VariantBuilder::set_genotypes </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::vector&lt; int32_t &gt;&gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>genotypes_for_all_samples</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the genotypes (GT) field for all samples at once by nested vector, MOVING the provided values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">genotypes_for_all_samples</td><td>genotypes for all samples in order of sample index, with one inner vector per sample (no padding necessary)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>With a nested vector, each inner vector represents the genotypes for the sample with the corresponding index. There is no need to manually pad to the maximum ploidy, but you do need to add a missing value (-1) for each missing/no-call allele.</dd></dl>
<p>For example, if you had Sample1=0/1 Sample2=./. Sample3=. Sample4=0/1/2 you would need to create the following nested vector:</p>
<p>{ {0, 1}, {-1, -1}, {}, {0, 1, 2} }</p>
<dl class="section note"><dt>Note</dt><dd>Does not support genotypes with phased alleles </dd>
<dd>
Less efficient than using a flattened vector </dd></dl>

</div>
</div>
<a class="anchor" id="acc79ab96a09514ea1a46dcbbceef3fef"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgamgee_1_1_variant_builder.html">VariantBuilder</a> &amp; gamgee::VariantBuilder::set_id </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the variant ID field. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>variant ID (typically DBSNP ID) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab39b8ab240ea63afd5fd69309c9c6bac"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgamgee_1_1_variant_builder.html">VariantBuilder</a> &amp; gamgee::VariantBuilder::set_integer_individual_field </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgamgee_1_1_variant_builder_multi_sample_vector.html">VariantBuilderMultiSampleVector</a>&lt; int32_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>values_for_all_samples</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set an integer individual field for all samples at once by name using an efficient flattened (one-dimensional) vector, COPYING the provided values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tag</td><td>name of the individual field to set </td></tr>
    <tr><td class="paramname">values_for_all_samples</td><td>field values for all samples as a <a class="el" href="classgamgee_1_1_variant_builder_multi_sample_vector.html" title="Class that allows you to efficiently prepare multi-sample data for setting individual fields in Varia...">VariantBuilderMultiSampleVector</a> (see note below)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>To create a multi-sample flattened vector for use with this function, first determine the number of samples and the maximum number of values per sample for this field, then get a pre-initialized vector from the builder:</dd></dl>
<p>auto multi_sample_vector = builder.get_integer_multi_sample_vector(num_samples, max_values_per_sample);</p>
<p>This vector will have missing values for all samples, with appropriate padding to the maximum field width.</p>
<p>Then, fill in the values for each non-missing sample by invoking the set_sample_value() and/or set_sample_values() functions on your multi-sample vector (set_sample_value() is more efficient than set_sample_values() since it doesn't require a vector construction/destruction for each call). You don't have to worry about samples with no values, since all samples start out with missing values.</p>
<p>Finally, pass your multi-sample vector into this function:</p>
<p>builder.set_integer_individual_field(field_name, multi_sample_vector);</p>
<p>If this process is too inconvenient, or you can't know the maximum number of values per sample in advance, use a less-efficient function that takes a nested vector.</p>
<dl class="section note"><dt>Note</dt><dd>Less efficient than moving the values into the builder </dd>
<dd>
Less efficient than setting using the field index </dd></dl>

</div>
</div>
<a class="anchor" id="a3ec4c931c83314e9c8b7e4d51dd3c1a7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgamgee_1_1_variant_builder.html">VariantBuilder</a> &amp; gamgee::VariantBuilder::set_integer_individual_field </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgamgee_1_1_variant_builder_multi_sample_vector.html">VariantBuilderMultiSampleVector</a>&lt; int32_t &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>values_for_all_samples</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set an integer individual field for all samples at once by name using an efficient flattened (one-dimensional) vector, MOVING the provided values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tag</td><td>name of the individual field to set </td></tr>
    <tr><td class="paramname">values_for_all_samples</td><td>field values for all samples as a <a class="el" href="classgamgee_1_1_variant_builder_multi_sample_vector.html" title="Class that allows you to efficiently prepare multi-sample data for setting individual fields in Varia...">VariantBuilderMultiSampleVector</a> (see note below)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>To create a multi-sample flattened vector for use with this function, first determine the number of samples and the maximum number of values per sample for this field, then get a pre-initialized vector from the builder:</dd></dl>
<p>auto multi_sample_vector = builder.get_integer_multi_sample_vector(num_samples, max_values_per_sample);</p>
<p>This vector will have missing values for all samples, with appropriate padding to the maximum field width.</p>
<p>Then, fill in the values for each non-missing sample by invoking the set_sample_value() and/or set_sample_values() functions on your multi-sample vector (set_sample_value() is more efficient than set_sample_values() since it doesn't require a vector construction/destruction for each call). You don't have to worry about samples with no values, since all samples start out with missing values.</p>
<p>Finally, MOVE your multi-sample vector into this function:</p>
<p>builder.set_integer_individual_field(field_name, std::move(multi_sample_vector));</p>
<p>If this process is too inconvenient, or you can't know the maximum number of values per sample in advance, use a less-efficient function that takes a nested vector.</p>
<dl class="section note"><dt>Note</dt><dd>Less efficient than setting using the field index </dd></dl>

</div>
</div>
<a class="anchor" id="afbdb45675372b4918a6895b692c35484"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgamgee_1_1_variant_builder.html">VariantBuilder</a> &amp; gamgee::VariantBuilder::set_integer_individual_field </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; int32_t &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>values_for_all_samples</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set an integer individual field for all samples at once by name using a nested vector, copying the provided values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tag</td><td>name of the individual field to set </td></tr>
    <tr><td class="paramname">values_for_all_samples</td><td>field values for all samples in order of sample index, with one inner vector per sample (no special padding necessary)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>With a nested vector, each inner vector represents the values for the sample with the corresponding index. There is no need to manually pad with missing/vector end values. For example:</dd></dl>
<p>{ {1, 2}, {3}, {}, {5, 6, 7} }</p>
<dl class="section note"><dt>Note</dt><dd>Less efficient than using a flattened vector </dd>
<dd>
Less efficient than moving the values into the builder </dd>
<dd>
Less efficient than setting using the field index </dd></dl>

</div>
</div>
<a class="anchor" id="a3d5f04cb707449afba36a2224aa8f0d0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgamgee_1_1_variant_builder.html">VariantBuilder</a> &amp; gamgee::VariantBuilder::set_integer_individual_field </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; int32_t &gt;&gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>values_for_all_samples</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set an integer individual field for all samples at once by name using a nested vector, moving the provided values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tag</td><td>name of the individual field to set </td></tr>
    <tr><td class="paramname">values_for_all_samples</td><td>field values for all samples in order of sample index, with one inner vector per sample (no special padding necessary)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>With a nested vector, each inner vector represents the values for the sample with the corresponding index. There is no need to manually pad with missing/vector end values. For example:</dd></dl>
<p>{ {1, 2}, {3}, {}, {5, 6, 7} }</p>
<dl class="section note"><dt>Note</dt><dd>Less efficient than using a flattened vector </dd>
<dd>
Less efficient than setting using the field index </dd></dl>

</div>
</div>
<a class="anchor" id="a4f48625de1d221b26175176b84f26431"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgamgee_1_1_variant_builder.html">VariantBuilder</a> &amp; gamgee::VariantBuilder::set_integer_individual_field </td>
          <td>(</td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>field_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgamgee_1_1_variant_builder_multi_sample_vector.html">VariantBuilderMultiSampleVector</a>&lt; int32_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>values_for_all_samples</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set an integer individual field for all samples at once by index using an efficient flattened (one-dimensional) vector, COPYING the provided values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field_index</td><td>index of the individual field to set (from a header lookup) </td></tr>
    <tr><td class="paramname">values_for_all_samples</td><td>field values for all samples as a <a class="el" href="classgamgee_1_1_variant_builder_multi_sample_vector.html" title="Class that allows you to efficiently prepare multi-sample data for setting individual fields in Varia...">VariantBuilderMultiSampleVector</a> (see note below)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>To create a multi-sample flattened vector for use with this function, first determine the number of samples and the maximum number of values per sample for this field, then get a pre-initialized vector from the builder:</dd></dl>
<p>auto multi_sample_vector = builder.get_integer_multi_sample_vector(num_samples, max_values_per_sample);</p>
<p>This vector will have missing values for all samples, with appropriate padding to the maximum field width.</p>
<p>Then, fill in the values for each non-missing sample by invoking the set_sample_value() and/or set_sample_values() functions on your multi-sample vector (set_sample_value() is more efficient than set_sample_values() since it doesn't require a vector construction/destruction for each call). You don't have to worry about samples with no values, since all samples start out with missing values.</p>
<p>Finally, pass your multi-sample vector into this function:</p>
<p>builder.set_integer_individual_field(field_index, multi_sample_vector);</p>
<p>If this process is too inconvenient, or you can't know the maximum number of values per sample in advance, use a less-efficient function that takes a nested vector.</p>
<dl class="section note"><dt>Note</dt><dd>Less efficient than moving the values into the builder </dd></dl>

</div>
</div>
<a class="anchor" id="adfc0eb4c39f5c09297508420ea715d58"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgamgee_1_1_variant_builder.html">VariantBuilder</a> &amp; gamgee::VariantBuilder::set_integer_individual_field </td>
          <td>(</td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>field_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgamgee_1_1_variant_builder_multi_sample_vector.html">VariantBuilderMultiSampleVector</a>&lt; int32_t &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>values_for_all_samples</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set an integer individual field for all samples at once by index using an efficient flattened (one-dimensional) vector, MOVING the provided values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field_index</td><td>index of the individual field to set (from a header lookup) </td></tr>
    <tr><td class="paramname">values_for_all_samples</td><td>field values for all samples as a <a class="el" href="classgamgee_1_1_variant_builder_multi_sample_vector.html" title="Class that allows you to efficiently prepare multi-sample data for setting individual fields in Varia...">VariantBuilderMultiSampleVector</a> (see note below)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>To create a multi-sample flattened vector for use with this function, first determine the number of samples and the maximum number of values per sample for this field, then get a pre-initialized vector from the builder:</dd></dl>
<p>auto multi_sample_vector = builder.get_integer_multi_sample_vector(num_samples, max_values_per_sample);</p>
<p>This vector will have missing values for all samples, with appropriate padding to the maximum field width.</p>
<p>Then, fill in the values for each non-missing sample by invoking the set_sample_value() and/or set_sample_values() functions on your multi-sample vector (set_sample_value() is more efficient than set_sample_values() since it doesn't require a vector construction/destruction for each call). You don't have to worry about samples with no values, since all samples start out with missing values.</p>
<p>Finally, MOVE your multi-sample vector into this function:</p>
<p>builder.set_integer_individual_field(field_index, std::move(multi_sample_vector));</p>
<p>If this process is too inconvenient, or you can't know the maximum number of values per sample in advance, use a less-efficient function that takes a nested vector. </p>

</div>
</div>
<a class="anchor" id="a3b5df29223c21d13cfcc397a9a4c91e0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgamgee_1_1_variant_builder.html">VariantBuilder</a> &amp; gamgee::VariantBuilder::set_integer_individual_field </td>
          <td>(</td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>field_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; int32_t &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>values_for_all_samples</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set an integer individual field for all samples at once by index using a nested vector, copying the provided values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field_index</td><td>index of the individual field to set (from a header lookup) </td></tr>
    <tr><td class="paramname">values_for_all_samples</td><td>field values for all samples in order of sample index, with one inner vector per sample (no special padding necessary)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>With a nested vector, each inner vector represents the values for the sample with the corresponding index. There is no need to manually pad with missing/vector end values. For example:</dd></dl>
<p>{ {1, 2}, {3}, {}, {5, 6, 7} }</p>
<dl class="section note"><dt>Note</dt><dd>Less efficient than using a flattened vector </dd>
<dd>
Less efficient than moving the values into the builder </dd></dl>

</div>
</div>
<a class="anchor" id="ae961d5aa85bed381ae45794c45c2cdc1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgamgee_1_1_variant_builder.html">VariantBuilder</a> &amp; gamgee::VariantBuilder::set_integer_individual_field </td>
          <td>(</td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>field_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; int32_t &gt;&gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>values_for_all_samples</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set an integer individual field for all samples at once by index using a nested vector, moving the provided values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field_index</td><td>index of the individual field to set (from a header lookup) </td></tr>
    <tr><td class="paramname">values_for_all_samples</td><td>field values for all samples in order of sample index, with one inner vector per sample (no special padding necessary)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>With a nested vector, each inner vector represents the values for the sample with the corresponding index. There is no need to manually pad with missing/vector end values. For example:</dd></dl>
<p>{ {1, 2}, {3}, {}, {5, 6, 7} }</p>
<dl class="section note"><dt>Note</dt><dd>Less efficient than using a flattened vector </dd></dl>

</div>
</div>
<a class="anchor" id="af6910634a94d22b99b9f5180f128af6b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgamgee_1_1_variant_builder.html">VariantBuilder</a> &amp; gamgee::VariantBuilder::set_integer_individual_field </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>sample</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int32_t&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set a single-valued integer individual field for a single sample by field and sample name. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tag</td><td>name of the individual field to set </td></tr>
    <tr><td class="paramname">sample</td><td>name of the sample whose value to set </td></tr>
    <tr><td class="paramname">value</td><td>field value for the specified sample</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>It's more efficient to use this setter instead of a vector-based setter when a sample has just a single value for a field </dd>
<dd>
Less efficient than setting using the field/sample indices </dd></dl>

</div>
</div>
<a class="anchor" id="a33e4dfd32226cc8f1a378f421ccdf4f9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgamgee_1_1_variant_builder.html">VariantBuilder</a> &amp; gamgee::VariantBuilder::set_integer_individual_field </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>sample</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; int32_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set a multi-valued integer individual field for a single sample by field and sample name. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tag</td><td>name of the individual field to set </td></tr>
    <tr><td class="paramname">sample</td><td>name of the sample whose value to set </td></tr>
    <tr><td class="paramname">values</td><td>field values for the specified sample</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Less efficient than setting using the field/sample indices </dd></dl>

</div>
</div>
<a class="anchor" id="abb6dbd3f1cc5ef9669ca1c691d0e2b4f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgamgee_1_1_variant_builder.html">VariantBuilder</a> &amp; gamgee::VariantBuilder::set_integer_individual_field </td>
          <td>(</td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>field_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>sample_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int32_t&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set a single-valued integer individual field for a single sample by field and sample index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field_index</td><td>index of the individual field to set (from a header lookup) </td></tr>
    <tr><td class="paramname">sample_index</td><td>index of the sample whose value to set (from a header lookup) </td></tr>
    <tr><td class="paramname">value</td><td>field value for the specified sample</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>It's more efficient to use this setter instead of a vector-based setter when a sample has just a single value for a field </dd></dl>

</div>
</div>
<a class="anchor" id="a721fca52e1a7228cbf390354e088e72c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgamgee_1_1_variant_builder.html">VariantBuilder</a> &amp; gamgee::VariantBuilder::set_integer_individual_field </td>
          <td>(</td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>field_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>sample_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; int32_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set a multi-valued integer individual field for a single sample by field and sample index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field_index</td><td>index of the individual field to set (from a header lookup) </td></tr>
    <tr><td class="paramname">sample_index</td><td>index of the sample whose value to set (from a header lookup) </td></tr>
    <tr><td class="paramname">values</td><td>field values for the specified sample </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7fa488e941d9ec047f1fa5c02b85ea2e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgamgee_1_1_variant_builder.html">VariantBuilder</a> &amp; gamgee::VariantBuilder::set_integer_shared_field </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int32_t&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set a single-valued integer shared field by field name. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tag</td><td>name of the shared field to set </td></tr>
    <tr><td class="paramname">value</td><td>new value for the field</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>It's more efficient to use this setter instead of a vector-based setter when a field has just a single value</dd>
<dd>
Less efficient than setting using the field index </dd></dl>

</div>
</div>
<a class="anchor" id="a65bdff18c82917e7a0bde43d64cae615"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgamgee_1_1_variant_builder.html">VariantBuilder</a> &amp; gamgee::VariantBuilder::set_integer_shared_field </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; int32_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set a multi-valued integer shared field by field name. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tag</td><td>name of the shared field to set </td></tr>
    <tr><td class="paramname">values</td><td>new values for the field</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Less efficient than setting using the field index </dd></dl>

</div>
</div>
<a class="anchor" id="adf2b2554997083141821365b163525c3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgamgee_1_1_variant_builder.html">VariantBuilder</a> &amp; gamgee::VariantBuilder::set_integer_shared_field </td>
          <td>(</td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int32_t&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set a single-valued integer shared field by field index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>index of the shared field to set (from a header lookup) </td></tr>
    <tr><td class="paramname">value</td><td>new value for the field</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>It's more efficient to use this setter instead of a vector-based setter when a field has just a single value </dd></dl>

</div>
</div>
<a class="anchor" id="a71808bcd6e8512abe46832be92f9ccdb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgamgee_1_1_variant_builder.html">VariantBuilder</a> &amp; gamgee::VariantBuilder::set_integer_shared_field </td>
          <td>(</td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; int32_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set a multi-valued integer shared field by field index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>index of the shared field to set (from a header lookup) </td></tr>
    <tr><td class="paramname">values</td><td>new values for the field </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af0a4a44483fe363a1e342f2c29681fae"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgamgee_1_1_variant_builder.html">VariantBuilder</a> &amp; gamgee::VariantBuilder::set_qual </td>
          <td>(</td>
          <td class="paramtype">const float&#160;</td>
          <td class="paramname"><em>qual</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the Phred-scaled site quality (probability that the site is not reference) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">qual</td><td>Phred-scaled site quality (probability that the site is not reference) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab94db2cdc82ac4afc66b91ff1155fd49"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgamgee_1_1_variant_builder.html">VariantBuilder</a> &amp; gamgee::VariantBuilder::set_ref_allele </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>ref_allele</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the reference allele. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ref_allele</td><td>reference allele as a string </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a395ac9f569128804788c00d8402ab065"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgamgee_1_1_variant_builder.html">VariantBuilder</a> &amp; gamgee::VariantBuilder::set_string_individual_field </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>values_for_all_samples</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set a string individual field for all samples at once by name, copying the provided values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tag</td><td>name of the individual field to set </td></tr>
    <tr><td class="paramname">values_for_all_samples</td><td>field values for all samples in order of sample index</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Less efficient than moving the values into the builder </dd>
<dd>
Less efficient than setting using the field index </dd></dl>

</div>
</div>
<a class="anchor" id="a94814cb21e8f545b674fc53e0c92d834"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgamgee_1_1_variant_builder.html">VariantBuilder</a> &amp; gamgee::VariantBuilder::set_string_individual_field </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::string &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>values_for_all_samples</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set a string individual field for all samples at once by name, moving the provided values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tag</td><td>name of the individual field to set </td></tr>
    <tr><td class="paramname">values_for_all_samples</td><td>field values for all samples in order of sample index</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Less efficient than setting using the field index </dd></dl>

</div>
</div>
<a class="anchor" id="a524e519089e1a40ae9a69e52a00b338d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgamgee_1_1_variant_builder.html">VariantBuilder</a> &amp; gamgee::VariantBuilder::set_string_individual_field </td>
          <td>(</td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>field_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>values_for_all_samples</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set a string individual field for all samples at once by index, copying the provided values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field_index</td><td>index of the individual field to set (from a header lookup) </td></tr>
    <tr><td class="paramname">values_for_all_samples</td><td>field values for all samples in order of sample index</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Less efficient than moving the values into the builder </dd></dl>

</div>
</div>
<a class="anchor" id="aab4c859786c762e8c8a91e61bbaf8cfa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgamgee_1_1_variant_builder.html">VariantBuilder</a> &amp; gamgee::VariantBuilder::set_string_individual_field </td>
          <td>(</td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>field_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::string &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>values_for_all_samples</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set a string individual field for all samples at once by index, moving the provided values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field_index</td><td>index of the individual field to set (from a header lookup) </td></tr>
    <tr><td class="paramname">values_for_all_samples</td><td>field values for all samples in order of sample index </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7e07de72742b9cc9e7b0743886ad7dea"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgamgee_1_1_variant_builder.html">VariantBuilder</a> &amp; gamgee::VariantBuilder::set_string_individual_field </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>sample</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set a string individual field for a single sample by field and sample name. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tag</td><td>name of the individual field to set </td></tr>
    <tr><td class="paramname">sample</td><td>name of the sample whose value to set </td></tr>
    <tr><td class="paramname">value</td><td>field value for the specified sample</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Less efficient than setting using the field/sample indices </dd></dl>

</div>
</div>
<a class="anchor" id="a93e57465db044273b3dc1ed9d843497b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgamgee_1_1_variant_builder.html">VariantBuilder</a> &amp; gamgee::VariantBuilder::set_string_individual_field </td>
          <td>(</td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>field_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>sample_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set a string individual field for a single sample by field and sample index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field_index</td><td>index of the individual field to set (from a header lookup) </td></tr>
    <tr><td class="paramname">sample_index</td><td>index of the sample whose value to set (from a header lookup) </td></tr>
    <tr><td class="paramname">value</td><td>field value for the specified sample </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aafc0bf24055d52a3278de0a366cf3554"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgamgee_1_1_variant_builder.html">VariantBuilder</a> &amp; gamgee::VariantBuilder::set_string_shared_field </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set a string shared field by field name. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tag</td><td>name of the shared field to set </td></tr>
    <tr><td class="paramname">value</td><td>new value for the field</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Less efficient than setting using the field index </dd></dl>

</div>
</div>
<a class="anchor" id="a00436fcaf17d72b1d61048195a50d8e7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgamgee_1_1_variant_builder.html">VariantBuilder</a> &amp; gamgee::VariantBuilder::set_string_shared_field </td>
          <td>(</td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set a string shared field by field index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>index of the shared field to set (from a header lookup) </td></tr>
    <tr><td class="paramname">value</td><td>new value for the field </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>gamgee/<a class="el" href="variant__builder_8h_source.html">variant_builder.h</a></li>
<li>gamgee/<a class="el" href="variant__builder_8cpp.html">variant_builder.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Nov 24 2014 16:31:26 for Gamgee by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.8
</small></address>
</body>
</html>
